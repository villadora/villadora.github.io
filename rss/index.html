<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[时光屋]]></title><description><![CDATA[The past is a ghost, the future a dream and all we ever have is now.]]></description><link>http://villadora.me/</link><generator>Ghost v0.4.2</generator><lastBuildDate>Fri, 17 Oct 2014 02:25:56 GMT</lastBuildDate><atom:link href="http://villadora.me/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Programmer's Enemy - Dependency Hell]]></title><description><![CDATA[<p>In a modular programming world, we have component-based software design, modular programming, etc. </p>

<p>There are a planty of articles talking about the benifits we can get from the good component design, I'm not going to talk in here. </p>

<ul>
<li><a href='http://requirejs.org/docs/why.html' #1">requirejs: Why we need webmodule?</a></li>
</ul>

<p>When we do modular design, just as we have already done in programming world decades, there is an enemy in our world: <strong>dependency hell</strong>.</p>

<p>You should heard of '<a href='http://en.wikipedia.org/wiki/DLL_Hell' >DLL Hell</a>'. A common cause is that apps shares libraries in the same location, so once there are two app depended on the same library with different versions, the former one breaks.</p>

<p><img src='http://villadora.me/content/images/2014/Jul/Sketch82142220.png'  alt="share the same library" /></p>

<p>To avoid that, programmers add versions to their libs and many package systems now don't store only one file in the shares folder, they add versions. </p>

<p>So there are more than one version of lib in the system. That's what <a href='http://bundler.io/' >bundle</a>, <a href='http://maven.apache.org/' >maven</a> do, the libraries will be stored in '.m2/', 'gems/'. That will looks like this:</p>

<p><img src='http://villadora.me/content/images/2014/Oct/Sketch82223133.png'  alt="with version" /></p>

<p>Or another solution is: instead of using shared lib path, using different lib path for each project, like using <strong>LD_LIBRARY_PATH</strong>, <strong>CLASS_PATH</strong>.</p>

<p><img src='http://villadora.me/content/images/2014/Oct/Sketch105132532-1.png'  alt="with custom path for each project" /></p>

<p>Now we have versions, but developers are lazy, people don't like to update their code every time one dependency update, but people want to enjoy the benefits of bug fixes, and in some cases, update your own file helps nothing:</p>

<p><img src='http://villadora.me/content/images/2014/Oct/Sketch105132634.png'  alt="upgrade chain" /></p>

<p>To make people get auto update for a bug fix, many package managers introduce version range, includes <strong>npm</strong>, <strong>rubygem</strong>, <strong>maven</strong>, etc.</p>

<p>Great, now if a lib my project depends on get a bug fix, I just do a simple upgrade or reinstall via <code>npm install</code>, <code>mvn install</code>, I get bug fixed without any code change.</p>

<p><img src='http://villadora.me/content/images/2014/Oct/Sketch10513308.png'  alt="upgrade nice" /></p>

<p>Great! We are now don't worried some one overwrite my libs! Are we in a safe world? <strong>NO</strong>.</p>

<p>Let us take a look at following story: </p>

<p>Your great project depended on <strong>X</strong>(1.0.0) and <strong>Y</strong>, <strong>Y</strong> also depended on <strong>X</strong> (1.0.0). Things works fine now, someday, <strong>X</strong> get upgraded to 1.1.0; it provides a wonderfull feature you have! But, you can not use it, until <strong>Y</strong> get upgraded. </p>

<p><img src='http://villadora.me/content/images/2014/Oct/Sketch105133130.png'  alt="deps hell" /></p>

<p>What about there are complex dependency tree here.</p>

<p><img src='http://villadora.me/content/images/2014/Oct/Sketch105133256.png'  alt="worse deps hell" /></p>

<p>So people have no choice to re-build the wheel. Wheels can not match each other. I see no package system get ride of that except <strong>node/npm</strong>.</p>

<p>Let see how node get ride of dependency hell in next article.</p>]]></description><link>http://villadora.me/2014/10/17/our-enemy-dependency-hell/</link><guid isPermaLink="false">2e1c53da-35cd-40c3-848b-64e947a1c8e8</guid><category><![CDATA[dependency]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Fri, 17 Oct 2014 01:26:28 GMT</pubDate></item><item><title><![CDATA[android模拟器中连接开发机器]]></title><description><![CDATA[<p>在模拟器中localhost已经被设置为虚拟机的机器，需要在本地调试的时候，通常需要在app里面连接本地起的server来调试连接和访问。但是localhost已经不能用了，而模拟器是绑定在一个虚拟的网络上的，在android开发网站上有<a href='http://developer.android.com/tools/devices/emulator.html' #networkaddresses'>http://developer.android.com/tools/devices/emulator.html#networkaddresses</a>, 说明把10.0.2.2这个地址绑定到了开发机器的localhost。就不用去尝试别的地址了。</p>

<p>而genymotion则是bind在10.0.3.2这个地址。</p>]]></description><link>http://villadora.me/2014/10/11/androidmo-ni-qi-zhong-lian-jie-kai-fa-ji-qi/</link><guid isPermaLink="false">4788ac02-ab8a-441d-944f-55e3f58b7ce8</guid><category><![CDATA[android]]></category><category><![CDATA[development]]></category><category><![CDATA[network]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Sat, 11 Oct 2014 01:31:01 GMT</pubDate></item><item><title><![CDATA[Android 学习笔记(2)]]></title><description><![CDATA[<h3 id="buildfromsource">build from source</h3>

<p>Android是一个开源系统，源码都是公开的， 可以到<a href='http://source.android.com/' 上去下载源码。'>http://source.android.com/上去下载源码。</a></p>

<p>具体的操作都在官网上这了：<a href='http://source.android.com/source/building.html' >http://source.android.com/source/building.html</a></p>

<p>首先，需要的是一个unix环境，window就装虚拟机装ubuntu吧，很多build的工具也只能在unix环境下用。</p>

<p>然后是装各种需要的工具和依赖库，包括bison，gmake之类。</p>

<p>在macos上要注意的一点是mac默认安装的时候都是大小写不敏感的文件系统，而android framework的文件是区分大小写的，官方的说法是大小写不敏感会影响git对文件的处理。所以我们需要一块大消息区分的磁盘区域。</p>

<p>有些老教程做法是用mac自带的工具去分了一块新的大小写区分的磁盘。千万不要这么做！虽然mac的磁盘工具不会影响你的数据，但新磁盘分区设计到老磁盘分区的大小调整，速度是非常非常慢。中间如果出现断电或者其他异常，就哭吧。 现在官方的推荐做法是新建一个磁盘镜像.dmg文件，对就是你平时看到的软件安装文件，然后再把这个镜像文件挂载到自己的目录下。</p>

<pre><code>hdiutil create -type SPARSE -fs 'Case-sensitive Journaled HFS+' -size 40g ~/android.dmg  
</code></pre>

<p>上面的命令会创建一个大小为40g的大小写区分的磁盘镜像。这个大小是对4.+以上系统的要求，有些老教程会分20G，等到编译的时候就哭了。（是的，我之前就是看了一篇老教程=.= 还是官方的靠谱）</p>

<p>对于mac上来说，还一个就是设置下文件句柄的数量限制,印象中mac默认设置是256,而在并行编译的过程中打开的文件数很可能超过，所以官方也是建议提高上限：</p>

<pre><code>ulimit -S -n 1024  
</code></pre>

<p>接下来我们就可以去下载源码了。</p>

<p>AOSP(Android Open Source Project)的源码管理也是用的git, 理论上来说你只要用git也就能clone项目了，但是你还是要去下一个小python脚本<code>repo</code>来帮助你管理源码。为什么？ 因为aosp下面的项目实在是太多了,从list上来看目前有684个项目，如果用git来一个个下载管理的话，要多麻烦有多麻烦。</p>

<pre><code>$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo
$ chmod a+x ~/bin/repo
</code></pre>

<p>下载repo，然后执行</p>

<pre><code>repo init -u https://android.googlesource.com/platform/manifest  
</code></pre>

<p>可以看到这是去访问了一个manifest路径，实际上就是把aosp的项目列表拉了下来,之后还会下载和生成一系列的辅助脚本。执行</p>

<pre><code>$ repo sync
</code></pre>

<p>下载就开始了，repo默认是使用并行下载，也支持断点续传,看起来是基于git branch的。</p>

<p>之后就是默默的等待代码下好了。</p>

<h3 id="defaultapps">default apps</h3>

<p>系统默认的app都在android源码里面可以找到，如果只想看这些app的代码的话，可以去<a href='https://github.com/android' >https://github.com/android</a> 里面找, 搜索apps的项目就好了。</p>

<p>比如找Launcher，可以搜到<code>platform_packages_apps_launcer</code>这就是系统自带的默认启动launcher：</p>

<p><a href='https://github.com/android/platform_packages_apps_launcher' >https://github.com/android/platform<em>packages</em>apps_launcher</a></p>]]></description><link>http://villadora.me/2014/09/28/android-xue-xi-bi-ji-2/</link><guid isPermaLink="false">d632eaa4-6a5a-4c7e-91a3-12336bdf01ed</guid><category><![CDATA[android]]></category><category><![CDATA[build]]></category><category><![CDATA[source]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Sun, 28 Sep 2014 04:00:34 GMT</pubDate></item><item><title><![CDATA[Android学习笔记(1)]]></title><description><![CDATA[<h4 id="securitysandbox">Security Sandbox 安全沙盒</h4>

<p>Android操作系统是基于多用户的iinux系统上的，从他的系统架构图就中可以看得很明显:</p>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Android-System-Architecture.svg/1000px-Android-System-Architecture.svg.png'  alt="Android System Architecture" /></p>

<p>所以很多地方Android都直接利用了linux的特性。</p>

<ul>
<li>Android里面每个应用都被当作linux系统中的一个用户，被赋予一个唯一的user ID。这个user ID只有操作系统知道，应用自己是不知道的(当然通过root之后没有什么不可能)。这样应用的文件也就很简单的可以通过user permission来设定。</li>
<li>每个应用都运行在独立的进程里，这样的好处是Android系统对应用的管理可以简化到对进程的管理，如挂起恢复等都可以直接用进程的特性。而内存管理也变得简单，因为不同的应用就是不同的进程，不会相互影响。</li>
<li>另外，每个京城都有着自己独立的虚拟机dvm，也就意味着应用都是运行在独立的虚拟机里的，虚拟机相当于沙盒，互相之间的影响非常小。</li>
</ul>

<p>当然应用之间不可能完全没有交流，Android提供了如下几种方式:</p>

<ul>
<li>两个应用如果是同一个组织个人开发，并且有着同样的签名，那么他们可以要求系统赋予他们一样的user ID，这样他们可以互相访问文件；而android在设计时为了节省系统资源，则认为既然你们都已经有一样的user ID，那么也在也没有必要把这两个应用区分到不同的进程和虚拟机中，所以有着一样的user id的应用会共享一样的linux process和虚拟机。</li>
<li>应用可以访问储存在各种设备上的数据，比如联系人，短信或者sd卡等。这些权限必须在安装时分配user ID的时候就给予之后是不能更改的，而一个应用需要哪些权限，需要通过manifest.xml来声明。</li>
<li>还有一种更通用的方法就是通过系统提供的广播机制，后面会提到的广播，相当于一个系统级的Message Bus。可以通过subscribe和send消息(Intent)来向其他应用程序发布消息。</li>
</ul>

<h4 id="applicationcomponents">Application Components 程序组件</h4>

<p>在Android系统中一个应用主要是由下面四种组件构成的:</p>

<ol>
<li>Activity: Activity代表了一个单独的screen，是能够响应外界事件的一个最小单位(还不是很清楚activity里面的view的结构，但是感觉很多软件都滥用了Activity,导致在Activities之间切换时每个Activity都需要消耗时间做初始化)。从文档历来看,Activity不应该是UI上的结构，而应该是一个程序逻辑上的结构，程序的Entry point,意味着外部可以不通过应用的其他部分直接访问到这个界面。而如果一个Activity是“私有的”，即不为外界所知也不响应外部消息的，那么应该整合进另一个Activity。  </li>
<li>Service: Service是一个后台服务，多用来执行一些长期运行的操作或者需要在另一个进程里执行的操作以避免当前应用进程阻塞。而Service是没有用户界面的。  </li>
<li>Content Provider:Content Provider提供了一组可以共享的数据，其他的应用程序可以访问甚至修改。而后面数据可以储存在文件系统，SQLLite数据库或者网络上。同样也Content Provider也可以被设置为私有。  </li>
<li>Broadcast Receiver:前面讲到了广播，而Broadcast receiver就是应用响应广播时间的组建，许多广播使用系统发出的，比如:锁频，电池没电等。而应用也可以发布广播，这样应用就可以通过广播相互交流。</li>
</ol>

<h4 id="intent">Intent消息</h4>

<p>在Android系统设计中，任何一个应用都可以启动其他应用的组件，可以是activity，也可以是service, broadcast receiver。在android中，应用的entry point并不是唯一的。样程序之间的整合能做的很好，但是现在这样看到的非常少，因为除了基础的功能，很多大家都愿意自己做一套新的而不是利用现有的。</p>

<p>每个应用都是不一样的，而且你也不知道这些应用是否已经安装，因此直接在代码中调用其他的应用是不现实的。这个时候就需要用到之前提到的message bus，而这个message bus做的还不仅仅是广播。通过向系统发送Intent，系统可以根据Intent的内容执行一定的操作，帮你激活应用。</p>

<p>Intent可以在components之间发送，不管是在一个应用内还是多个应用之间。对于activities和services，Intent会定义要做什么和对什么数据(通过URL),而对于broadcast receivers，intent则只定义一个一直的动作。而content providerz则是由contentResolver来激活的。</p>

<ul>
<li>start activity: <a href='http://developer.android.com/reference/android/content/Context.html' #startActivity(android.content.Intent)">startActivity()</a> <a href='http://developer.android.com/reference/android/app/Activity.html' #startActivityForResult(android.content.Intent, int)">startActivityForResult()</a></li>
<li>start service: <a href='http://developer.android.com/reference/android/content/Context.html' #startService(android.content.Intent)">startService()</a> <a href='http://developer.android.com/reference/android/content/Context.html' #bindService(android.content.Intent, android.content.ServiceConnection, int)">bindService()</a></li>
<li>initial broadcast: <a href='http://developer.android.com/reference/android/content/Context.html' #sendBroadcast(android.content.Intent)">sendBroadcast()</a> <a href='http://developer.android.com/reference/android/content/Context.html' #sendOrderedBroadcast(android.content.Intent, java.lang.String)">sendOrderedBroadcast()</a> <a href='http://developer.android.com/reference/android/content/Context.html' #sendStickyBroadcast(android.content.Intent)">sendStickBroadcast()</a></li>
<li>query content provider: <a href='http://developer.android.com/reference/android/content/ContentProvider.html' #query(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String)">ContentResolver.query()</a></li>
</ul>

<h4 id="manifestfile">Manifest File</h4>

<p>Android应用的根目录下都有一个文件*AndroidManifest.xml“， 而他主要做几件事情：</p>

<ol>
<li>申明应用所包含的components，这样系统就知道这个应用有多少components，能够对什么消息作出相应，能够如何被激活。同时也会在里面包含这些components能做什么的信息，这样当系统受到一个Intent说要执行actionA的时候，系统就知道要去找谁了。  </li>
<li>申明应用所需的权限，如果没有这些权限应用就无法正常工作，所以在安装是系统就根据=manifest file=里的内容告知用户应用需要这些权限，否则就不给安装。这个步骤不能逐个控制经被诟病蛮久了，很多无关的应用都要求访问联系人短信等权限，你只有不装或者忍受两种选择。  </li>
<li>申明最低系统需求，这个是通过<a href='http://developer.android.com/guide/topics/manifest/uses-sdk-element.html' #ApiLevels">API Level</a> API Level就是一个数字，越新的版本数字越大，所以只要系统的数字大于应用所申明的数字，那么这个应用就可以运行。  </li>
<li>申明需要的硬件和软件功能，如蓝牙，摄像头等。也包含屏幕尺寸啊输入的要求之类的信息  </li>
<li>需要的而外的libraries</li>
</ol>

<h4 id="applicationresources">Application Resources</h4>

<p>一个应用除了代码还会有图片音效视频的资源文件，这些文件都被统一管理了起来放在res/目录下。而Android sdk build tools则对每一个资源都生成一个unique ID，并在R.java里面生成这些ID的reference。这样你在代码里就能够直接引用这些资源。并且对于不同的密度，资源也是不一样的。</p>]]></description><link>http://villadora.me/2014/09/12/androidxue-xi-bi-ji-1/</link><guid isPermaLink="false">861b100f-86e1-4d00-a669-cc55bc770842</guid><category><![CDATA[android]]></category><category><![CDATA[note]]></category><category><![CDATA[learning]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Fri, 12 Sep 2014 03:34:58 GMT</pubDate></item><item><title><![CDATA[Gralde Note]]></title><description><![CDATA[<ul>
<li>使用groovy语法,定义在build.gralde中</li>
</ul>

<pre><code>println "hello"  
</code></pre>

<ul>
<li>和makefile，ant一样定义task</li>
</ul>

<pre><code>task hello {  
    doLast {
        println "my task"
    }
}

task hello &lt;&lt; {  
   println "shortcut for task"
}
</code></pre>

<ul>
<li>同样可以定义依赖，生成DAG</li>
</ul>

<pre><code>task next(dependsOn: first) &lt;&lt; {  
    println "my next task"
}
</code></pre>

<ul>
<li>能够在DAG上挂载hook</li>
</ul>

<pre><code>gradle.taskGraph.beforeTask { Task task -&gt;  
    println "executing $task ..."
}

gradle.taskGraph.afterTask { Task task, TaskState state -&gt;  
    if (state.failure) {
        println "FAILED"
    }
    else {
        println "done"
    }
}
</code></pre>

<ul>
<li>通过settings.gradle来配置common behavior，对套嵌的projects进行配置。依赖方式相反，内部project依赖外部的project tasks</li>
</ul>]]></description><link>http://villadora.me/2014/09/12/gralde-note/</link><guid isPermaLink="false">054f4468-11c1-4eb2-bc2d-00fc6955911d</guid><category><![CDATA[gralde]]></category><category><![CDATA[note]]></category><category><![CDATA[learning]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Fri, 12 Sep 2014 03:26:25 GMT</pubDate></item><item><title><![CDATA[toFastProperties in bluebirds]]></title><description><![CDATA[<p><a href='http://stackoverflow.com/questions/24987896/how-does-bluebirds-util-tofastproperties-function-make-an-objects-properties/24989927' #24989927">ToFastProperties in bluebirds</a></p>

<p>非常有趣的回答，解释了为什么下面这段代码能够提高property access的速度。</p>

<pre><code class="javascript">function toFastProperties(obj) {  
    /*jshint -W027*/
    function f() {}
    f.prototype = obj;
    ASSERT("%HasFastProperties", true, obj);
    return f;
    eval(obj);
}
</code></pre>]]></description><link>http://villadora.me/2014/07/29/tofastproperties-in-bluebirds/</link><guid isPermaLink="false">4ec62de1-c8b3-460c-89ea-743b44e9bfde</guid><category><![CDATA[javascript]]></category><category><![CDATA[nodejs]]></category><category><![CDATA[performance]]></category><category><![CDATA[v8]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Tue, 29 Jul 2014 06:33:50 GMT</pubDate></item><item><title><![CDATA[couchdb 1.5/1.6中的Proxy Authentication]]></title><description><![CDATA[<p>因为最近要在<code>couchdb</code>中使用<a href='http://couchdb.readthedocs.org/en/latest/api/server/authn.html' #api-auth-proxy"><strong>Proxy Authentication</strong></a></p>

<p>于是参照文档，修改<em>local.ini</em>配置为:</p>

<pre><code>authentication_handlers = {couch_httpd_auth, cookie_authentication_handler}, {couch_httpd_auth, proxy_authentication_handler}, {couch_httpd_auth, default_authentication_handler}  
</code></pre>

<p>但是参照文档中修改配置之后,启动服务，会出现如下错误：</p>

<pre><code>{
    error: "unknown_error",
    reason: "undef"
}
</code></pre>

<p>最后查看了<a href='http://www.apache.org/dist/couchdb/notes/1.6.0/apache-couchdb-1.6.0.html' >couchdb 1.6 releae notes</a>发现, proxy_authentication_handler是之后加上的，而之前叫做proxy_authentification_handler。 当然了，我使用的couchdb还没那么潮的更新到1.6，还是1.5的版本。</p>

<p>就想说升级不能够同样也保留老的名字吗，都1.x了还不注意兼容。</p>]]></description><link>http://villadora.me/2014/07/28/couchdb-1-6gai-dong/</link><guid isPermaLink="false">6ec04850-b704-495c-bd7a-9844c2e62bd0</guid><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Mon, 28 Jul 2014 08:48:44 GMT</pubDate></item><item><title><![CDATA[node中的Readable - flowing/non-flowing mode]]></title><description><![CDATA[<p>大家都知道在node中<code>Readable</code> Stream有两种模式: <code>flowing mode</code>和<code>non-flowing mode</code>。</p>

<p>对于<code>flowing mode</code>的<code>Readable</code> Stream, 我们是没法控制它何时去读数据读多少的，它会去尽快的去消耗data,并emit出来。</p>

<pre><code class="javascript">// in lib/_stream_readable.js
if (state.flowing &amp;&amp; state.length === 0 &amp;&amp;!state.sync) {  
        stream.emit('data', chunk);
        stream.read(0);
</code></pre>

<p>而<code>non-flowing mode</code>的Readable Stream, 则不会主动的去读数据，需要自己显示的去调用<code>read</code>方法才能得到数据。</p>

<pre><code>// in lib/_stream_readable.js
// update the buffer info.
state.length += state.objectMode ? 1 : chunk.length;  
if (addToFront)  
  state.buffer.unshift(chunk);
else  
  state.buffer.push(chunk);
</code></pre>

<p>可以看到当有数据时，只是将数据放入buffer中，而不是直接emit。</p>

<p>所以如果想控制stream的读取顺序，大小和时间，应该使用<code>non-flowing mode</code>，而当使用pipe有下游管道对数据进行处理时，这个时候数据的读取和处理应该交给下游管道处理，应该尽可能快的提供数据，所以要使用<code>flowing mode</code>。而这也是node会在attach 'data'事件之后，自动转变为<code>flowing mode</code>的原因，避免错误的使用或者忘记切换模式。</p>

<p>而pipe时则会注册<code>data</code>事件，所以使用了pipe也会转换为<code>flowing mode</code>。</p>

<pre><code class="javascript">var src = this;  
...
src.on('data', ondata);
</code></pre>]]></description><link>http://villadora.me/2014/07/24/nodezhong-de-readable-flowingnon-flowing-mode/</link><guid isPermaLink="false">b4991594-e0f1-4c26-839e-36696dc5c618</guid><category><![CDATA[flowing mode]]></category><category><![CDATA[non-flowing mode]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Thu, 24 Jul 2014 02:15:47 GMT</pubDate></item><item><title><![CDATA[扯扯Scala]]></title><description><![CDATA[<p>在stackoverflow上看到一个关于<a href='http://stackoverflow.com/questions/3606591/why-does-intellij-idea-compile-scala-so-slowly' >Why does IntelliJ IDEA compile Scala so slowly?</a>的问题，顿时感到scala在语法层面做的许多杰出的设计，但是为了和java兼容，最终在一定程度上限制了自己的发展。</p>

<p>scala可能是为了快速的在各个公司里面推动，选择了完全和java现有代码兼容，而不是只在二进制层面上保持一致。</p>

<p>scala的sdk和类型系统都建立在java的类型系统之上的，而目标是工业使用的scala语言需要提供大量的内置工具，而一个建立在java类型系统之上的更复杂的类型系统则不得不付出在编译时的开销。</p>

<p>scala的类型检测对于大型项目非常重要，但是是否能够有选项使得能够某些时候能用来最快速开发，而不做类型检测？ 不过scala一开始就不是瞄准着脚本语言去做的，而脚本语言则更容易构建原型系统或执行轻量级的任务。</p>

<p>没有过大型项目使用scala的经验。所以基本是随便扯扯。</p>

<p>其实对于大型项目来说，一定是有多个部分（可能是一个人开发，更多的情况是由不同的团队开发）组成的，而组件之间的沟通与协作则是很容易出问题的地方。静态类型语言在大型项目开发上更有优势的地方是程序代替人对代码做了严格检测，以丧失灵活性为代价。这样可以避免一些错误，可以降低程序员的标准，可以大规模的招人，以人海战术来实现企业目标。</p>

<p>静态类型语言更适合一个牛人写出框架和核心代码，分离出接口，然后将接下来的工作用时间人力来填补。项目进度对于企业来说是可控的。</p>

<p>而静态类型检测会强迫人以机器的方式去编写代码，实际上很多时候需要做类型转换，数据传递转移等，对于人来说，一些很明确的使用场景需要更复杂的操作来进行，好比写文章的时候有了更多的条条框框，导致笔跟不上大脑的速度。</p>

<p>scala尝试去提供快速方便的语法糖，隐式的类型推导来方便程序员实现快速开发，然后使用静态类型检测和原有java代码的兼容来方便建立大型系统。</p>]]></description><link>http://villadora.me/2014/07/23/scalaxing-neng-he-lei-xing-jian-ce/</link><guid isPermaLink="false">fb6b0fcd-f0a0-4523-86cc-20f0a59b2d1a</guid><category><![CDATA[scale]]></category><category><![CDATA[大型项目]]></category><category><![CDATA[类型检测]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Wed, 23 Jul 2014 13:57:59 GMT</pubDate></item><item><title><![CDATA[Http API设计]]></title><description><![CDATA[<p>Heroku团队根据heroku platform api和他们自己内部系统的实践经验总结了一些http api设计的准则，发布到了github上。 <br />
地址:</p>

<p><a href='https://github.com/interagent/http-api-design' >https://github.com/interagent/http-api-design</a></p>

<p>鉴于见到太多公司的http接口没有按照标准规范来实施，推荐做服务接口设计和前端的同学都看看。</p>

<p>其中很重要的几条抽出来：</p>

<ul>
<li>返回正确的状态代码</li>
</ul>

<p>不要始终使用200! 201,202对应不同的<strong>METHOD</strong>是很有意义的。 出现错误是应该返回正确的状态码，是请求参数错误请返回400，是服务器内部出错请返回500，服务器压力过大需要kill连接请返回503，对于行为错误而不是权限问题不要使用401而要用403。这些状态代码本身都有意义，不需要去而外的创建代码或者用额外的属性。</p>

<ul>
<li>以ISO8601格式来使用UTC时间</li>
</ul>

<p>记得使用UTC,同时格式统一，真的需要在每个项目里面去引用moment.js来处理时间？时区和格式足够头痛了，moment.js也不是万能的。</p>

<ul>
<li>给出结构化的错误信息</li>
</ul>

<p>错误不要只返回给状态吗，能够给出一定错误信息的情况下要在body中返回统一的结构化的错误信息。这样客户端也可以做出正确的处理，是等待之后重试还是停止请求通知用户。</p>

<p>当然还有很多就不一一细列了。去看heroku团队的指南吧</p>]]></description><link>http://villadora.me/2014/07/11/http-apishe-ji/</link><guid isPermaLink="false">033dce8c-eb1c-4495-952e-25f49d004c44</guid><category><![CDATA[http]]></category><category><![CDATA[rest]]></category><category><![CDATA[api]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Fri, 11 Jul 2014 14:00:49 GMT</pubDate></item><item><title><![CDATA[迁移到Ghost]]></title><description><![CDATA[<p>从octopress迁移到ghost，有后台可以live review的平台还是比裸写markdown的感觉更好。</p>

<p>ghost要导入之前的博客需要进入 <em>'host/ghost/debug'</em> 来导入json文件，做了个小工具去扫 <code>_posts</code> 下面的 <code>*.md</code>和<code>*.mardown</code>文件, 最终生成 <code>exports.json</code> 可以导入ghost.</p>

<p><a href='http://npmjs.org/oghost' >npmjs.org/oghost</a></p>

<pre><code class="bash">npm install oghost -g  
cd _posts  
oghost &gt; exports.json  
</code></pre>

<p>导入的时候发现ghost的tag和post对应关系生成不了，报了</p>

<pre><code>Unique Constraint failed in tag field  
</code></pre>

<p>但是tags里面是没有重复的，很奇怪，有人知道什么原因么？</p>]]></description><link>http://villadora.me/2014/07/09/qian-yi-dao-ghost/</link><guid isPermaLink="false">a242e3d8-ae82-4782-a22b-33fa3343a7c4</guid><category><![CDATA[ghost]]></category><category><![CDATA[blog]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Wed, 09 Jul 2014 08:35:34 GMT</pubDate></item><item><title><![CDATA[AMD到CommonJS的转换]]></title><description><![CDATA[<p>CommonJS和AMD的争论已经有很多，而两者也在项目进化和融合。</p>

<p>个人看来CommonJS更面向于开发者，对于开发者来说，需要的是清晰的版本和管理，更少的代码和干扰，更少的配置。而AMD在代码中允许匿名模块，模块名称和变量之间关系的不清晰，非就近依赖，冗余依赖定义都不是开发者友好。</p>

<p><a href='http://www.npmjs.com/require2commonjs' >require2commonjs</a> 提供了命令行和node模块来将在requirejs中使用的AMD转化为CommonJS格式，方便其他使用CMD或者 <a href='http://nodejs.org/' >node</a> <a href='http://github.com/cortexjs/cortex' >cortex</a> 等外部系统来使用。</p>

<p>目前的官方AMD提供一下几种方式去定义一个模块：</p>

<p>1) Dependency-free module, simple object</p>

<pre><code class=" javascript">define({  
    add: function(a, b) { return a + b; }
});
</code></pre>

<p>没有任何依赖，直接定义模块的exports。这种情况下要将AMD转话为CommonJS模块，只需要变为</p>

<pre><code class=" javascript">module.exports = {  
    add: function(a, b) { return a + b; }
};
</code></pre>

<p>语法树转换非常简单。</p>

<p>2) Simplified CommonJS wrapping</p>

<pre><code class=" javascript"> define(function (require, exports, module) {
     var a = require('a'),
         b = require('b');
     exports.action = function () {};
 });
</code></pre>

<p>现在AMD提供CommonJS wrapping这种格式，更为简单。 只需要将factory函数中的函数体提取出来就可以了</p>

<pre><code class=" javascript">var a = require('a'),  
    b = require('b');

exports.action = function () {};  
</code></pre>

<p>3) Normalized</p>

<p>这个是通常我们见到的AMD格式</p>

<pre><code class=" javascript">define(['backbone', './util', 'Buffer'], function(Bakcbone, util) {  
    // other process
    return {
       data: {}
   };
});
</code></pre>

<p>对于这种格式，处理有两个步骤 1) 将依赖转变为require的形式，中间要注意的是依赖申明和 factory 的参数并不一定一致； 2) 将 return 转变为 module.exports</p>

<pre><code class="javascript">var Backbone = require('backbone');  
var util = require('./util');  
require('Buffer');

module.exports = { data: {} };  
</code></pre>]]></description><link>http://villadora.me/2014/05/24/amd-define-and-how-to-translate-amd-to-co/</link><guid isPermaLink="false">458bef5d-b1cb-4223-8df8-153dee4f26c6</guid><category><![CDATA[javascript]]></category><category><![CDATA[amd]]></category><category><![CDATA[commonjs]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Fri, 23 May 2014 17:06:59 GMT</pubDate></item><item><title><![CDATA[regexp.toString()]]></title><description><![CDATA[<p>Regexp.toString在不同浏览器下修辞符顺序不一致。</p>

<p>Chrome, firefox</p>

<pre><code>var re = /abc/gim;  
re.toString(); // return '/abc/gim'  
</code></pre>

<p>IE 9.0</p>

<pre><code>var re = /abc/gim;  
re.toString(); // return '/abc/igm'  
</code></pre>]]></description><link>http://villadora.me/2014/05/21/regexptost/</link><guid isPermaLink="false">9bddac02-815c-4bff-acaa-9a3fb95c680f</guid><category><![CDATA[javascript]]></category><category><![CDATA[browsers]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Wed, 21 May 2014 11:17:55 GMT</pubDate></item><item><title><![CDATA[Cookie Version in J2EE]]></title><description><![CDATA[<p>在处理Cookie的时候发现不能处理servlet request中不能获取cookie中的带":"字符的值.</p>

<pre><code class="java">Cookie[] cookies = request.getCookies();  
if (cookies != null) {  
    for (Cookie cookie : cookies) {
        if (StringUtils.equalsIgnoreCase(cookie.getName(), name)) {
            value = cookie.getValue(); // if the value in cookie is 'http://example.com' then here it will get 'http'
            break;
        }
    }
}
</code></pre>

<p>这是因为目前Cookie有两个标准，一个是Version 0 (<a href='http://curl.haxx.se/rfc/cookie_spec.html' >Netscape spec</a>)</p>

<p>而J2EE的实现描述 Cookie#setValue 中</p>

<pre><code>With Version 0 cookies, values should not contain white space, brackets, parentheses, equals signs, commas, double quotes, slashes, question marks, at signs, colons, and semicolons. Empty values may not behave the same way on all browsers.  
</code></pre>

<p>`</p>

<p>也就是说Version 0 是不能包含空格，括弧，等号，逗号， 双引号等字符的。 </p>

<p>而Version 1 (<a href='http://www.ietf.org/rfc/rfc2109.txt' >RFC 2109 spec</a>) 是可以的。</p>

<p>但是javax.servlet.http.Cookie的实现时默认是使用 Version 0</p>

<pre><code>By default, cookies are created according to the Netscape cookie specification. The version can be changed with the  
setVersion method.  
</code></pre>

<p>而看起来container默认的选择也是使用了Version 0而没有去改变version。所以当Cookie值中带有':'时，就无法读到colon后的内容。</p>

<p>如果没有办法改container并且只能使用默认的request的话，暂时的解决方案是在写cookie的时候URLEncode, 然后在服务器端读的时候做URLDecode。</p>]]></description><link>http://villadora.me/2014/05/06/cookie-version/</link><guid isPermaLink="false">a3c2a196-34b6-4c9b-bbd4-fa257e8f8135</guid><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Tue, 06 May 2014 05:34:00 GMT</pubDate></item><item><title><![CDATA[Iscroll5的几个bug]]></title><description><![CDATA[<p>Iscroll是在移动端开发不可缺少的组件，至少在实现原生的overflow:scroll之前。其中碰到有两个问题。</p>

<ol>
<li>Function.prototype.bind iscroll5在indicator中使用了bind, 但是这个bind在2.x的android浏览器上和webview中都没法使用，导致脚本出错。</li>
</ol>

<pre><code>this.fadeTimeout = setTimeout((function (val) {  
    this.wrapperStyle.opacity = val;
    this.visible = +val;
}).bind(this, val), delay);
</code></pre>

<p>去掉bind, 改成closure解决问题</p>

<pre><code>var selft = this;  
self.fadetimeout = setTimeout(function (val) {  
    self.wrapperStyle.opacity = val;
    self.visible = +val;
}, delay);
</code></pre>

<p>这个修正已经有人发了 pullrequest 只不过暂时还没有merge到master分支中。</p>

<ol>
<li>click事件多次触发。在有些浏览器上会发现使用了iscroll的元素click事件会导致多次触发, 这是因为iscroll为了模拟滑动事件，屏蔽了scroll元素上的click事件，而自己通过touchend来决定是否触发模拟的click事件。但是在移动上的有些浏览器上e.preventDefault并不能阻止事件，因为click事件的cancelable为false。 这个时候只能检测e.cancelable属性，然后决定是否要产生模拟事件。</li>
</ol>]]></description><link>http://villadora.me/2014/04/08/isroll-event-preventdefault/</link><guid isPermaLink="false">4d8523e9-1014-4618-9343-1f58b40abfe4</guid><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Tue, 08 Apr 2014 02:18:00 GMT</pubDate></item></channel></rss>