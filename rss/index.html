<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[时光屋]]></title><description><![CDATA[The past is a ghost, the future a dream and all we ever have is now.]]></description><link>http://villadora.me/</link><generator>Ghost v0.4.2</generator><lastBuildDate>Fri, 12 Sep 2014 03:35:32 GMT</lastBuildDate><atom:link href="http://villadora.me/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Android学习笔记(1)]]></title><description><![CDATA[<h4 id="securitysandbox">Security Sandbox 安全沙盒</h4>

<p>Android操作系统是基于多用户的iinux系统上的，从他的系统架构图就中可以看得很明显:</p>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Android-System-Architecture.svg/1000px-Android-System-Architecture.svg.png'  alt="Android System Architecture" /></p>

<p>所以很多地方Android都直接利用了linux的特性。</p>

<ul>
<li>Android里面每个应用都被当作linux系统中的一个用户，被赋予一个唯一的user ID。这个user ID只有操作系统知道，应用自己是不知道的(当然通过root之后没有什么不可能)。这样应用的文件也就很简单的可以通过user permission来设定。</li>
<li>每个应用都运行在独立的进程里，这样的好处是Android系统对应用的管理可以简化到对进程的管理，如挂起恢复等都可以直接用进程的特性。而内存管理也变得简单，因为不同的应用就是不同的进程，不会相互影响。</li>
<li>另外，每个京城都有着自己独立的虚拟机dvm，也就意味着应用都是运行在独立的虚拟机里的，虚拟机相当于沙盒，互相之间的影响非常小。</li>
</ul>

<p>当然应用之间不可能完全没有交流，Android提供了如下几种方式:</p>

<ul>
<li>两个应用如果是同一个组织个人开发，并且有着同样的签名，那么他们可以要求系统赋予他们一样的user ID，这样他们可以互相访问文件；而android在设计时为了节省系统资源，则认为既然你们都已经有一样的user ID，那么也在也没有必要把这两个应用区分到不同的进程和虚拟机中，所以有着一样的user id的应用会共享一样的linux process和虚拟机。</li>
<li>应用可以访问储存在各种设备上的数据，比如联系人，短信或者sd卡等。这些权限必须在安装时分配user ID的时候就给予之后是不能更改的，而一个应用需要哪些权限，需要通过manifest.xml来声明。</li>
<li>还有一种更通用的方法就是通过系统提供的广播机制，后面会提到的广播，相当于一个系统级的Message Bus。可以通过subscribe和send消息(Intent)来向其他应用程序发布消息。</li>
</ul>

<h4 id="applicationcomponents">Application Components 程序组件</h4>

<p>在Android系统中一个应用主要是由下面四种组件构成的:</p>

<ol>
<li>Activity: Activity代表了一个单独的screen，是能够响应外界事件的一个最小单位(还不是很清楚activity里面的view的结构，但是感觉很多软件都滥用了Activity,导致在Activities之间切换时每个Activity都需要消耗时间做初始化)。从文档历来看,Activity不应该是UI上的结构，而应该是一个程序逻辑上的结构，程序的Entry point,意味着外部可以不通过应用的其他部分直接访问到这个界面。而如果一个Activity是“私有的”，即不为外界所知也不响应外部消息的，那么应该整合进另一个Activity。  </li>
<li>Service: Service是一个后台服务，多用来执行一些长期运行的操作或者需要在另一个进程里执行的操作以避免当前应用进程阻塞。而Service是没有用户界面的。  </li>
<li>Content Provider:Content Provider提供了一组可以共享的数据，其他的应用程序可以访问甚至修改。而后面数据可以储存在文件系统，SQLLite数据库或者网络上。同样也Content Provider也可以被设置为私有。  </li>
<li>Broadcast Receiver:前面讲到了广播，而Broadcast receiver就是应用响应广播时间的组建，许多广播使用系统发出的，比如:锁频，电池没电等。而应用也可以发布广播，这样应用就可以通过广播相互交流。</li>
</ol>

<h4 id="intent">Intent消息</h4>

<p>在Android系统设计中，任何一个应用都可以启动其他应用的组件，可以是activity，也可以是service, broadcast receiver。在android中，应用的entry point并不是唯一的。样程序之间的整合能做的很好，但是现在这样看到的非常少，因为除了基础的功能，很多大家都愿意自己做一套新的而不是利用现有的。</p>

<p>每个应用都是不一样的，而且你也不知道这些应用是否已经安装，因此直接在代码中调用其他的应用是不现实的。这个时候就需要用到之前提到的message bus，而这个message bus做的还不仅仅是广播。通过向系统发送Intent，系统可以根据Intent的内容执行一定的操作，帮你激活应用。</p>

<p>Intent可以在components之间发送，不管是在一个应用内还是多个应用之间。对于activities和services，Intent会定义要做什么和对什么数据(通过URL),而对于broadcast receivers，intent则只定义一个一直的动作。而content providerz则是由contentResolver来激活的。</p>

<ul>
<li>start activity: <a href='http://developer.android.com/reference/android/content/Context.html' #startActivity(android.content.Intent)">startActivity()</a> <a href='http://developer.android.com/reference/android/app/Activity.html' #startActivityForResult(android.content.Intent, int)">startActivityForResult()</a></li>
<li>start service: <a href='http://developer.android.com/reference/android/content/Context.html' #startService(android.content.Intent)">startService()</a> <a href='http://developer.android.com/reference/android/content/Context.html' #bindService(android.content.Intent, android.content.ServiceConnection, int)">bindService()</a></li>
<li>initial broadcast: <a href='http://developer.android.com/reference/android/content/Context.html' #sendBroadcast(android.content.Intent)">sendBroadcast()</a> <a href='http://developer.android.com/reference/android/content/Context.html' #sendOrderedBroadcast(android.content.Intent, java.lang.String)">sendOrderedBroadcast()</a> <a href='http://developer.android.com/reference/android/content/Context.html' #sendStickyBroadcast(android.content.Intent)">sendStickBroadcast()</a></li>
<li>query content provider: <a href='http://developer.android.com/reference/android/content/ContentProvider.html' #query(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String)">ContentResolver.query()</a></li>
</ul>

<h4 id="manifestfile">Manifest File</h4>

<p>Android应用的根目录下都有一个文件*AndroidManifest.xml“， 而他主要做几件事情：</p>

<ol>
<li>申明应用所包含的components，这样系统就知道这个应用有多少components，能够对什么消息作出相应，能够如何被激活。同时也会在里面包含这些components能做什么的信息，这样当系统受到一个Intent说要执行actionA的时候，系统就知道要去找谁了。  </li>
<li>申明应用所需的权限，如果没有这些权限应用就无法正常工作，所以在安装是系统就根据=manifest file=里的内容告知用户应用需要这些权限，否则就不给安装。这个步骤不能逐个控制经被诟病蛮久了，很多无关的应用都要求访问联系人短信等权限，你只有不装或者忍受两种选择。  </li>
<li>申明最低系统需求，这个是通过<a href='http://developer.android.com/guide/topics/manifest/uses-sdk-element.html' #ApiLevels">API Level</a> API Level就是一个数字，越新的版本数字越大，所以只要系统的数字大于应用所申明的数字，那么这个应用就可以运行。  </li>
<li>申明需要的硬件和软件功能，如蓝牙，摄像头等。也包含屏幕尺寸啊输入的要求之类的信息  </li>
<li>需要的而外的libraries</li>
</ol>

<h4 id="applicationresources">Application Resources</h4>

<p>一个应用除了代码还会有图片音效视频的资源文件，这些文件都被统一管理了起来放在res/目录下。而Android sdk build tools则对每一个资源都生成一个unique ID，并在R.java里面生成这些ID的reference。这样你在代码里就能够直接引用这些资源。并且对于不同的密度，资源也是不一样的。</p>]]></description><link>http://villadora.me/2014/09/12/androidxue-xi-bi-ji-1/</link><guid isPermaLink="false">861b100f-86e1-4d00-a669-cc55bc770842</guid><category><![CDATA[android]]></category><category><![CDATA[note]]></category><category><![CDATA[learning]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Fri, 12 Sep 2014 03:34:58 GMT</pubDate></item><item><title><![CDATA[Gralde Note]]></title><description><![CDATA[<ul>
<li>使用groovy语法,定义在build.gralde中</li>
</ul>

<pre><code>println "hello"  
</code></pre>

<ul>
<li>和makefile，ant一样定义task</li>
</ul>

<pre><code>task hello {  
    doLast {
        println "my task"
    }
}

task hello &lt;&lt; {  
   println "shortcut for task"
}
</code></pre>

<ul>
<li>同样可以定义依赖，生成DAG</li>
</ul>

<pre><code>task next(dependsOn: first) &lt;&lt; {  
    println "my next task"
}
</code></pre>

<ul>
<li>能够在DAG上挂载hook</li>
</ul>

<pre><code>gradle.taskGraph.beforeTask { Task task -&gt;  
    println "executing $task ..."
}

gradle.taskGraph.afterTask { Task task, TaskState state -&gt;  
    if (state.failure) {
        println "FAILED"
    }
    else {
        println "done"
    }
}
</code></pre>

<ul>
<li>通过settings.gradle来配置common behavior，对套嵌的projects进行配置。依赖方式相反，内部project依赖外部的project tasks</li>
</ul>]]></description><link>http://villadora.me/2014/09/12/gralde-note/</link><guid isPermaLink="false">054f4468-11c1-4eb2-bc2d-00fc6955911d</guid><category><![CDATA[gralde]]></category><category><![CDATA[note]]></category><category><![CDATA[learning]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Fri, 12 Sep 2014 03:26:25 GMT</pubDate></item><item><title><![CDATA[toFastProperties in bluebirds]]></title><description><![CDATA[<p><a href='http://stackoverflow.com/questions/24987896/how-does-bluebirds-util-tofastproperties-function-make-an-objects-properties/24989927' #24989927">ToFastProperties in bluebirds</a></p>

<p>非常有趣的回答，解释了为什么下面这段代码能够提高property access的速度。</p>

<pre><code class="javascript">function toFastProperties(obj) {  
    /*jshint -W027*/
    function f() {}
    f.prototype = obj;
    ASSERT("%HasFastProperties", true, obj);
    return f;
    eval(obj);
}
</code></pre>]]></description><link>http://villadora.me/2014/07/29/tofastproperties-in-bluebirds/</link><guid isPermaLink="false">4ec62de1-c8b3-460c-89ea-743b44e9bfde</guid><category><![CDATA[javascript]]></category><category><![CDATA[nodejs]]></category><category><![CDATA[performance]]></category><category><![CDATA[v8]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Tue, 29 Jul 2014 06:33:50 GMT</pubDate></item><item><title><![CDATA[couchdb 1.5/1.6中的Proxy Authentication]]></title><description><![CDATA[<p>因为最近要在<code>couchdb</code>中使用<a href='http://couchdb.readthedocs.org/en/latest/api/server/authn.html' #api-auth-proxy"><strong>Proxy Authentication</strong></a></p>

<p>于是参照文档，修改<em>local.ini</em>配置为:</p>

<pre><code>authentication_handlers = {couch_httpd_auth, cookie_authentication_handler}, {couch_httpd_auth, proxy_authentication_handler}, {couch_httpd_auth, default_authentication_handler}  
</code></pre>

<p>但是参照文档中修改配置之后,启动服务，会出现如下错误：</p>

<pre><code>{
    error: "unknown_error",
    reason: "undef"
}
</code></pre>

<p>最后查看了<a href='http://www.apache.org/dist/couchdb/notes/1.6.0/apache-couchdb-1.6.0.html' >couchdb 1.6 releae notes</a>发现, proxy_authentication_handler是之后加上的，而之前叫做proxy_authentification_handler。 当然了，我使用的couchdb还没那么潮的更新到1.6，还是1.5的版本。</p>

<p>就想说升级不能够同样也保留老的名字吗，都1.x了还不注意兼容。</p>]]></description><link>http://villadora.me/2014/07/28/couchdb-1-6gai-dong/</link><guid isPermaLink="false">6ec04850-b704-495c-bd7a-9844c2e62bd0</guid><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Mon, 28 Jul 2014 08:48:44 GMT</pubDate></item><item><title><![CDATA[node中的Readable - flowing/non-flowing mode]]></title><description><![CDATA[<p>大家都知道在node中<code>Readable</code> Stream有两种模式: <code>flowing mode</code>和<code>non-flowing mode</code>。</p>

<p>对于<code>flowing mode</code>的<code>Readable</code> Stream, 我们是没法控制它何时去读数据读多少的，它会去尽快的去消耗data,并emit出来。</p>

<pre><code class="javascript">// in lib/_stream_readable.js
if (state.flowing &amp;&amp; state.length === 0 &amp;&amp;!state.sync) {  
        stream.emit('data', chunk);
        stream.read(0);
</code></pre>

<p>而<code>non-flowing mode</code>的Readable Stream, 则不会主动的去读数据，需要自己显示的去调用<code>read</code>方法才能得到数据。</p>

<pre><code>// in lib/_stream_readable.js
// update the buffer info.
state.length += state.objectMode ? 1 : chunk.length;  
if (addToFront)  
  state.buffer.unshift(chunk);
else  
  state.buffer.push(chunk);
</code></pre>

<p>可以看到当有数据时，只是将数据放入buffer中，而不是直接emit。</p>

<p>所以如果想控制stream的读取顺序，大小和时间，应该使用<code>non-flowing mode</code>，而当使用pipe有下游管道对数据进行处理时，这个时候数据的读取和处理应该交给下游管道处理，应该尽可能快的提供数据，所以要使用<code>flowing mode</code>。而这也是node会在attach 'data'事件之后，自动转变为<code>flowing mode</code>的原因，避免错误的使用或者忘记切换模式。</p>

<p>而pipe时则会注册<code>data</code>事件，所以使用了pipe也会转换为<code>flowing mode</code>。</p>

<pre><code class="javascript">var src = this;  
...
src.on('data', ondata);
</code></pre>]]></description><link>http://villadora.me/2014/07/24/nodezhong-de-readable-flowingnon-flowing-mode/</link><guid isPermaLink="false">b4991594-e0f1-4c26-839e-36696dc5c618</guid><category><![CDATA[flowing mode]]></category><category><![CDATA[non-flowing mode]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Thu, 24 Jul 2014 02:15:47 GMT</pubDate></item><item><title><![CDATA[扯扯Scala]]></title><description><![CDATA[<p>在stackoverflow上看到一个关于<a href='http://stackoverflow.com/questions/3606591/why-does-intellij-idea-compile-scala-so-slowly' >Why does IntelliJ IDEA compile Scala so slowly?</a>的问题，顿时感到scala在语法层面做的许多杰出的设计，但是为了和java兼容，最终在一定程度上限制了自己的发展。</p>

<p>scala可能是为了快速的在各个公司里面推动，选择了完全和java现有代码兼容，而不是只在二进制层面上保持一致。</p>

<p>scala的sdk和类型系统都建立在java的类型系统之上的，而目标是工业使用的scala语言需要提供大量的内置工具，而一个建立在java类型系统之上的更复杂的类型系统则不得不付出在编译时的开销。</p>

<p>scala的类型检测对于大型项目非常重要，但是是否能够有选项使得能够某些时候能用来最快速开发，而不做类型检测？ 不过scala一开始就不是瞄准着脚本语言去做的，而脚本语言则更容易构建原型系统或执行轻量级的任务。</p>

<p>没有过大型项目使用scala的经验。所以基本是随便扯扯。</p>

<p>其实对于大型项目来说，一定是有多个部分（可能是一个人开发，更多的情况是由不同的团队开发）组成的，而组件之间的沟通与协作则是很容易出问题的地方。静态类型语言在大型项目开发上更有优势的地方是程序代替人对代码做了严格检测，以丧失灵活性为代价。这样可以避免一些错误，可以降低程序员的标准，可以大规模的招人，以人海战术来实现企业目标。</p>

<p>静态类型语言更适合一个牛人写出框架和核心代码，分离出接口，然后将接下来的工作用时间人力来填补。项目进度对于企业来说是可控的。</p>

<p>而静态类型检测会强迫人以机器的方式去编写代码，实际上很多时候需要做类型转换，数据传递转移等，对于人来说，一些很明确的使用场景需要更复杂的操作来进行，好比写文章的时候有了更多的条条框框，导致笔跟不上大脑的速度。</p>

<p>scala尝试去提供快速方便的语法糖，隐式的类型推导来方便程序员实现快速开发，然后使用静态类型检测和原有java代码的兼容来方便建立大型系统。</p>]]></description><link>http://villadora.me/2014/07/23/scalaxing-neng-he-lei-xing-jian-ce/</link><guid isPermaLink="false">fb6b0fcd-f0a0-4523-86cc-20f0a59b2d1a</guid><category><![CDATA[scale]]></category><category><![CDATA[大型项目]]></category><category><![CDATA[类型检测]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Wed, 23 Jul 2014 13:57:59 GMT</pubDate></item><item><title><![CDATA[Http API设计]]></title><description><![CDATA[<p>Heroku团队根据heroku platform api和他们自己内部系统的实践经验总结了一些http api设计的准则，发布到了github上。 <br />
地址:</p>

<p><a href='https://github.com/interagent/http-api-design' >https://github.com/interagent/http-api-design</a></p>

<p>鉴于见到太多公司的http接口没有按照标准规范来实施，推荐做服务接口设计和前端的同学都看看。</p>

<p>其中很重要的几条抽出来：</p>

<ul>
<li>返回正确的状态代码</li>
</ul>

<p>不要始终使用200! 201,202对应不同的<strong>METHOD</strong>是很有意义的。 出现错误是应该返回正确的状态码，是请求参数错误请返回400，是服务器内部出错请返回500，服务器压力过大需要kill连接请返回503，对于行为错误而不是权限问题不要使用401而要用403。这些状态代码本身都有意义，不需要去而外的创建代码或者用额外的属性。</p>

<ul>
<li>以ISO8601格式来使用UTC时间</li>
</ul>

<p>记得使用UTC,同时格式统一，真的需要在每个项目里面去引用moment.js来处理时间？时区和格式足够头痛了，moment.js也不是万能的。</p>

<ul>
<li>给出结构化的错误信息</li>
</ul>

<p>错误不要只返回给状态吗，能够给出一定错误信息的情况下要在body中返回统一的结构化的错误信息。这样客户端也可以做出正确的处理，是等待之后重试还是停止请求通知用户。</p>

<p>当然还有很多就不一一细列了。去看heroku团队的指南吧</p>]]></description><link>http://villadora.me/2014/07/11/http-apishe-ji/</link><guid isPermaLink="false">033dce8c-eb1c-4495-952e-25f49d004c44</guid><category><![CDATA[http]]></category><category><![CDATA[rest]]></category><category><![CDATA[api]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Fri, 11 Jul 2014 14:00:49 GMT</pubDate></item><item><title><![CDATA[迁移到Ghost]]></title><description><![CDATA[<p>从octopress迁移到ghost，有后台可以live review的平台还是比裸写markdown的感觉更好。</p>

<p>ghost要导入之前的博客需要进入 <em>'host/ghost/debug'</em> 来导入json文件，做了个小工具去扫 <code>_posts</code> 下面的 <code>*.md</code>和<code>*.mardown</code>文件, 最终生成 <code>exports.json</code> 可以导入ghost.</p>

<p><a href='http://npmjs.org/oghost' >npmjs.org/oghost</a></p>

<pre><code class="bash">npm install oghost -g  
cd _posts  
oghost &gt; exports.json  
</code></pre>

<p>导入的时候发现ghost的tag和post对应关系生成不了，报了</p>

<pre><code>Unique Constraint failed in tag field  
</code></pre>

<p>但是tags里面是没有重复的，很奇怪，有人知道什么原因么？</p>]]></description><link>http://villadora.me/2014/07/09/qian-yi-dao-ghost/</link><guid isPermaLink="false">a242e3d8-ae82-4782-a22b-33fa3343a7c4</guid><category><![CDATA[ghost]]></category><category><![CDATA[blog]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Wed, 09 Jul 2014 08:35:34 GMT</pubDate></item><item><title><![CDATA[AMD到CommonJS的转换]]></title><description><![CDATA[<p>CommonJS和AMD的争论已经有很多，而两者也在项目进化和融合。</p>

<p>个人看来CommonJS更面向于开发者，对于开发者来说，需要的是清晰的版本和管理，更少的代码和干扰，更少的配置。而AMD在代码中允许匿名模块，模块名称和变量之间关系的不清晰，非就近依赖，冗余依赖定义都不是开发者友好。</p>

<p><a href='http://www.npmjs.com/require2commonjs' >require2commonjs</a> 提供了命令行和node模块来将在requirejs中使用的AMD转化为CommonJS格式，方便其他使用CMD或者 <a href='http://nodejs.org/' >node</a> <a href='http://github.com/cortexjs/cortex' >cortex</a> 等外部系统来使用。</p>

<p>目前的官方AMD提供一下几种方式去定义一个模块：</p>

<p>1) Dependency-free module, simple object</p>

<pre><code class=" javascript">define({  
    add: function(a, b) { return a + b; }
});
</code></pre>

<p>没有任何依赖，直接定义模块的exports。这种情况下要将AMD转话为CommonJS模块，只需要变为</p>

<pre><code class=" javascript">module.exports = {  
    add: function(a, b) { return a + b; }
};
</code></pre>

<p>语法树转换非常简单。</p>

<p>2) Simplified CommonJS wrapping</p>

<pre><code class=" javascript"> define(function (require, exports, module) {
     var a = require('a'),
         b = require('b');
     exports.action = function () {};
 });
</code></pre>

<p>现在AMD提供CommonJS wrapping这种格式，更为简单。 只需要将factory函数中的函数体提取出来就可以了</p>

<pre><code class=" javascript">var a = require('a'),  
    b = require('b');

exports.action = function () {};  
</code></pre>

<p>3) Normalized</p>

<p>这个是通常我们见到的AMD格式</p>

<pre><code class=" javascript">define(['backbone', './util', 'Buffer'], function(Bakcbone, util) {  
    // other process
    return {
       data: {}
   };
});
</code></pre>

<p>对于这种格式，处理有两个步骤 1) 将依赖转变为require的形式，中间要注意的是依赖申明和 factory 的参数并不一定一致； 2) 将 return 转变为 module.exports</p>

<pre><code class="javascript">var Backbone = require('backbone');  
var util = require('./util');  
require('Buffer');

module.exports = { data: {} };  
</code></pre>]]></description><link>http://villadora.me/2014/05/24/amd-define-and-how-to-translate-amd-to-co/</link><guid isPermaLink="false">458bef5d-b1cb-4223-8df8-153dee4f26c6</guid><category><![CDATA[javascript]]></category><category><![CDATA[amd]]></category><category><![CDATA[commonjs]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Fri, 23 May 2014 17:06:59 GMT</pubDate></item><item><title><![CDATA[regexp.toString()]]></title><description><![CDATA[<p>Regexp.toString在不同浏览器下修辞符顺序不一致。</p>

<p>Chrome, firefox</p>

<pre><code>var re = /abc/gim;  
re.toString(); // return '/abc/gim'  
</code></pre>

<p>IE 9.0</p>

<pre><code>var re = /abc/gim;  
re.toString(); // return '/abc/igm'  
</code></pre>]]></description><link>http://villadora.me/2014/05/21/regexptost/</link><guid isPermaLink="false">9bddac02-815c-4bff-acaa-9a3fb95c680f</guid><category><![CDATA[javascript]]></category><category><![CDATA[browsers]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Wed, 21 May 2014 11:17:55 GMT</pubDate></item><item><title><![CDATA[Cookie Version in J2EE]]></title><description><![CDATA[<p>在处理Cookie的时候发现不能处理servlet request中不能获取cookie中的带":"字符的值.</p>

<pre><code class="java">Cookie[] cookies = request.getCookies();  
if (cookies != null) {  
    for (Cookie cookie : cookies) {
        if (StringUtils.equalsIgnoreCase(cookie.getName(), name)) {
            value = cookie.getValue(); // if the value in cookie is 'http://example.com' then here it will get 'http'
            break;
        }
    }
}
</code></pre>

<p>这是因为目前Cookie有两个标准，一个是Version 0 (<a href='http://curl.haxx.se/rfc/cookie_spec.html' >Netscape spec</a>)</p>

<p>而J2EE的实现描述 Cookie#setValue 中</p>

<pre><code>With Version 0 cookies, values should not contain white space, brackets, parentheses, equals signs, commas, double quotes, slashes, question marks, at signs, colons, and semicolons. Empty values may not behave the same way on all browsers.  
</code></pre>

<p>`</p>

<p>也就是说Version 0 是不能包含空格，括弧，等号，逗号， 双引号等字符的。 </p>

<p>而Version 1 (<a href='http://www.ietf.org/rfc/rfc2109.txt' >RFC 2109 spec</a>) 是可以的。</p>

<p>但是javax.servlet.http.Cookie的实现时默认是使用 Version 0</p>

<pre><code>By default, cookies are created according to the Netscape cookie specification. The version can be changed with the  
setVersion method.  
</code></pre>

<p>而看起来container默认的选择也是使用了Version 0而没有去改变version。所以当Cookie值中带有':'时，就无法读到colon后的内容。</p>

<p>如果没有办法改container并且只能使用默认的request的话，暂时的解决方案是在写cookie的时候URLEncode, 然后在服务器端读的时候做URLDecode。</p>]]></description><link>http://villadora.me/2014/05/06/cookie-version/</link><guid isPermaLink="false">a3c2a196-34b6-4c9b-bbd4-fa257e8f8135</guid><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Tue, 06 May 2014 05:34:00 GMT</pubDate></item><item><title><![CDATA[Iscroll5的几个bug]]></title><description><![CDATA[<p>Iscroll是在移动端开发不可缺少的组件，至少在实现原生的overflow:scroll之前。其中碰到有两个问题。</p>

<ol>
<li>Function.prototype.bind iscroll5在indicator中使用了bind, 但是这个bind在2.x的android浏览器上和webview中都没法使用，导致脚本出错。</li>
</ol>

<pre><code>this.fadeTimeout = setTimeout((function (val) {  
    this.wrapperStyle.opacity = val;
    this.visible = +val;
}).bind(this, val), delay);
</code></pre>

<p>去掉bind, 改成closure解决问题</p>

<pre><code>var selft = this;  
self.fadetimeout = setTimeout(function (val) {  
    self.wrapperStyle.opacity = val;
    self.visible = +val;
}, delay);
</code></pre>

<p>这个修正已经有人发了 pullrequest 只不过暂时还没有merge到master分支中。</p>

<ol>
<li>click事件多次触发。在有些浏览器上会发现使用了iscroll的元素click事件会导致多次触发, 这是因为iscroll为了模拟滑动事件，屏蔽了scroll元素上的click事件，而自己通过touchend来决定是否触发模拟的click事件。但是在移动上的有些浏览器上e.preventDefault并不能阻止事件，因为click事件的cancelable为false。 这个时候只能检测e.cancelable属性，然后决定是否要产生模拟事件。</li>
</ol>]]></description><link>http://villadora.me/2014/04/08/isroll-event-preventdefault/</link><guid isPermaLink="false">4d8523e9-1014-4618-9343-1f58b40abfe4</guid><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Tue, 08 Apr 2014 02:18:00 GMT</pubDate></item><item><title><![CDATA[在cluster中使用passport openID]]></title><description><![CDATA[<h1 id="passportopenidincluster">Passport openid in cluster</h1>

<p>使用nodejs的cluster可以让我们更好的利用cpu资源, 但是同时也会带来一些问题.</p>

<h2 id="session">session</h2>

<p>这个大家都应该知道如果使用in memory session, 那么不同的cluster之间就不能共享session也会导致login失败, 解决办法很简单,使用redis或者mongo这种持久层来保存cookie, 或者可以使用sticky-session之类来固定cluster (但是stikcy-session这个模块是基于ip，在proxy背后会失去作用，没有找到源码，不推荐).</p>

<h2 id="openidassociation">open id association</h2>

<p>association是用来在replyParty和openID provider之间建立一个共享的secret, 这样在接下来的访问中就可以通过association来判断对方是不是伪造的。 <br />
但是再使用了cluster之后,http请求被分发给了不同的process, 前面拿到的association在另一个process里面正常的模式下是拿不到的，这个时候请求会被当作一个没有授权的请求,从而要求用户重新登录。解决办法是在passport的strategy中设置saveAssociation和loadAssociation将openIdAssocation存到redis或者mongodb中。</p>

<pre><code class=" js">    var passport = require('passport');
    var strategy = new GoogleStrategy({
        returnURL: callbackURL,
        realm: realm,
        stateless: true
    };

    // ...

    strategy.saveAssociation(function(handle, provider, algorithm, secret, expiresIn, done) {
        var assoc = {
            handle: handle,
            provider: provider,
            algorithm: algorithm,
            secret: secret,
            expiresIn: expiresIn
        };

        // save to redis/mongodb
        save(function(err) {
            done(err);
        });
    });

    strategy.loadAssociation(function(handle, done) {
        // load from redis/mongodb
        load(handle, function(err, assoc) {
            if(err) return done(err);
            done(err, assoc.provider, assoc.algorithm, assoc.secret);
        });
    });

    passport.use(strategy);
</code></pre>]]></description><link>http://villadora.me/2014/03/06/passport-openid-nodejs/</link><guid isPermaLink="false">85d3107e-eb1a-416a-b2ba-bf8f4ea63c08</guid><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Thu, 06 Mar 2014 07:18:00 GMT</pubDate></item><item><title><![CDATA[javascript arguments长度限制]]></title><description><![CDATA[<p>先看下这一段代码片段(in chrome):</p>

<pre><code class="javascript">var a = [];  
a[2&lt;&lt;16] = 1;  
fucntion b() {}  
b.apply([], a);  
</code></pre>

<p>这段代码最终回导致RangeError: Maximum call stack size exceed. 实际上并不是因为调用栈满了，而只是数组长度太长了.
为什么会这样呢？ 不是在<code>a[2&lt;&lt;16] = 1</code>的时候还好好的吗？
大家都知道javascript的数组并不是真的数组，而只是一个特殊的以数组作为key的table而已，这点和lua是一样的。所以当我们在执行<code>a[2&lt;&lt;16] = 1</code>的时候，其实这生成的只不过是一个只有一个键值<em>2&lt;&lt;16</em>的表，空间只有1，这是没有任何问题的。</p>

<p>但当我们把一个数组作为arguments传递给一个函数时，情况就变了；同样，大家都知道arguments不是真的数组，它没有Array.push/pop等方法。但是我们可以把一个数组作为参数传递给apply方法，作为argumetns去调用一个函数。</p>

<p>实际的情况是，在这个时候你的数组虽然是一个table，但是在这个时候只能一个个的传递到栈上，没错,因为arguments是分配在Stack上的，而Array是分配在Heap上的。</p>

<p>从某种意义上来说arguments才是真正的数组: 线性空间排序, 顺序访问。而Array更像上是Hash Table。接下来发生什么？javascript vm尝试去读取arguments中的参数，一个一个的把它放到调用栈上，传递给之后调用的函数,于是<code>for(var i = 0; i &lt; (2&lt;&lt;16); ++)...</code>，调用栈都被使用满了！</p>

<p>本来只占据Heap中一个位置，现在占据了整个栈的空间。而调用栈空间满了之后，会发生什么错误？就是我们开头看到的<em>RangeError: Maximum call stack size exceed.</em>， 而实际上叫做<em>Function arguments exceed the maximun limit.</em>更好些.</p>]]></description><link>http://villadora.me/2013/08/09/arguments-exceed-javascript/</link><guid isPermaLink="false">488317f1-8bb3-4a52-9247-c2b900d2200f</guid><category><![CDATA[arguments]]></category><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Thu, 08 Aug 2013 16:00:19 GMT</pubDate></item><item><title><![CDATA[interupt when hexo generating]]></title><description><![CDATA[<p>用<code>hexo generate</code>的时候有时强制中断了，下次再重新generate就会失败, 预计是<code>db.json</code>还没有完全生成完，而重新generate的时候会去尝试读<code>db.json</code>，这个时候就会报错，删除<code>db.json</code>就ok. 奇怪的是作者为什么在报错之后不直接重新生成<code>db.json</code>，毕竟这个文件只是用来做server的数据库，莫非还有别的用途?</p>]]></description><link>http://villadora.me/2013/08/06/interupt-when-hexo-generating/</link><guid isPermaLink="false">da89da35-754f-4a0c-b95b-75ef057fccd9</guid><dc:creator><![CDATA[villadora]]></dc:creator><pubDate>Tue, 06 Aug 2013 13:51:11 GMT</pubDate></item></channel></rss>