<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[时光屋]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://villadora.github.io/"/>
  <updated>2014-05-01T14:32:03.180Z</updated>
  <id>http://villadora.github.io/</id>
  
  <author>
    <name><![CDATA[Villa Dora]]></name>
    <email><![CDATA[jky239@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Iscroll5的几个bug]]></title>
    <link href="http://villadora.github.io/2014/04/08/isroll-event-preventDefault/"/>
    <id>http://villadora.github.io/2014/04/08/isroll-event-preventDefault/</id>
    <published>2014-04-08T02:18:00.000Z</published>
    <updated>2014-05-01T12:20:23.000Z</updated>
    <content type="html"><![CDATA[<p>Iscroll是在移动端开发不可缺少的组件，至少在实现原生的overflow:scroll之前。其中碰到有两个问题。</p>
<ol>
<li>Function.prototype.bind iscroll5在indicator中使用了bind, 但是这个bind在2.x的android浏览器上和webview中都没法使用，导致脚本出错。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">this</span>.fadeTimeout = setTimeout((function (<span class="keyword">val</span>) {
    <span class="keyword">this</span>.wrapperStyle.opacity = <span class="keyword">val</span>;
    <span class="keyword">this</span>.visible = +<span class="keyword">val</span>;
}).bind(<span class="keyword">this</span>, <span class="keyword">val</span>), delay);
</pre></td></tr></table></figure>

<p>去掉bind, 改成closure解决问题</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> selft = this;
<span class="keyword">self</span>.fadetimeout = setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
    <span class="keyword">self</span>.wrapperStyle.opacity = val;
    <span class="keyword">self</span>.visible = +val;
}, delay);
</pre></td></tr></table></figure>

<p>这个修正已经有人发了 pullrequest 只不过暂时还没有merge到master分支中。</p>
<ol>
<li>click事件多次触发。在有些浏览器上会发现使用了iscroll的元素click事件会导致多次触发, 这是因为iscroll为了模拟滑动事件，屏蔽了scroll元素上的click事件，而自己通过touchend来决定是否触发模拟的click事件。但是在移动上的有些浏览器上e.preventDefault并不能阻止事件，因为click事件的cancelable为false。 这个时候只能检测e.cancelable属性，然后决定是否要产生模拟事件。</li>
</ol>
]]></content>
    
    
      <category term="mobile" scheme="http://villadora.github.io/tags/mobile/"/>
    
      <category term="android" scheme="http://villadora.github.io/tags/android/"/>
    
      <category term="iscroll" scheme="http://villadora.github.io/tags/iscroll/"/>
    
      <category term="javascript" scheme="http://villadora.github.io/tags/javascript/"/>
    
      <category term="Web" scheme="http://villadora.github.io/categories/Web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在cluster中使用passport openID]]></title>
    <link href="http://villadora.github.io/2014/03/06/passport-openid-nodejs/"/>
    <id>http://villadora.github.io/2014/03/06/passport-openid-nodejs/</id>
    <published>2014-03-06T07:18:00.000Z</published>
    <updated>2014-05-01T12:20:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Passport_openid_in_cluster">Passport openid in cluster</h1>
<p>使用nodejs的cluster可以让我们更好的利用cpu资源, 但是同时也会带来一些问题.</p>
<h2 id="session">session</h2>
<p>这个大家都应该知道如果使用in memory session, 那么不同的cluster之间就不能共享session也会导致login失败, 解决办法很简单,使用redis或者mongo这种持久层来保存cookie, 或者可以使用sticky-session之类来固定cluster (但是stikcy-session这个模块是基于ip，在proxy背后会失去作用，没有找到源码，不推荐).</p>
<h2 id="open_id_association">open id association</h2>
<p>association是用来在replyParty和openID provider之间建立一个共享的secret, 这样在接下来的访问中就可以通过association来判断对方是不是伪造的。<br>但是再使用了cluster之后,http请求被分发给了不同的process, 前面拿到的association在另一个process里面正常的模式下是拿不到的，这个时候请求会被当作一个没有授权的请求,从而要求用户重新登录。解决办法是在passport的strategy中设置saveAssociation和loadAssociation将openIdAssocation存到redis或者mongodb中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre>    <span class="keyword">var</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>);
    <span class="keyword">var</span> strategy = <span class="keyword">new</span> GoogleStrategy({
        returnURL: callbackURL,
        realm: realm,
        stateless: <span class="literal">true</span>
    };
    
    <span class="comment">// ...</span>

    strategy.saveAssociation(<span class="function"><span class="keyword">function</span><span class="params">(handle, provider, algorithm, secret, expiresIn, done)</span> {</span>
        <span class="keyword">var</span> assoc = {
            handle: handle,
            provider: provider,
            algorithm: algorithm,
            secret: secret,
            expiresIn: expiresIn
        };
        
        <span class="comment">// save to redis/mongodb</span>
        save(<span class="function"><span class="keyword">function</span><span class="params">(err)</span> {</span>
            done(err);
        });
    });

    strategy.loadAssociation(<span class="function"><span class="keyword">function</span><span class="params">(handle, done)</span> {</span>
        <span class="comment">// load from redis/mongodb</span>
        load(handle, <span class="function"><span class="keyword">function</span><span class="params">(err, assoc)</span> {</span>
            <span class="keyword">if</span>(err) <span class="keyword">return</span> done(err);
            done(err, assoc.provider, assoc.algorithm, assoc.secret);
        });
    });
    
    passport.use(strategy);
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="passport" scheme="http://villadora.github.io/tags/passport/"/>
    
      <category term="openid" scheme="http://villadora.github.io/tags/openid/"/>
    
      <category term="nodejs" scheme="http://villadora.github.io/tags/nodejs/"/>
    
      <category term="cluster" scheme="http://villadora.github.io/tags/cluster/"/>
    
      <category term="javascript" scheme="http://villadora.github.io/tags/javascript/"/>
    
      <category term="Nodejs" scheme="http://villadora.github.io/categories/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[javascript arguments长度限制]]></title>
    <link href="http://villadora.github.io/2013/08/08/arguments-exceed-javascript/"/>
    <id>http://villadora.github.io/2013/08/08/arguments-exceed-javascript/</id>
    <published>2013-08-08T08:00:19.000Z</published>
    <updated>2013-09-02T02:23:11.000Z</updated>
    <content type="html"><![CDATA[<p>先看下这一段代码片段(in chrome):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> a = [];
a[<span class="number">2</span>&lt;&lt;<span class="number">16</span>] = <span class="number">1</span>;
fucntion b() {}
b.apply([], a);
</pre></td></tr></table></figure>

<p>这段代码最终回导致RangeError: Maximum call stack size exceed. 实际上并不是因为调用栈满了，而只是数组长度太长了.<br>为什么会这样呢？ 不是在<code>a[2&lt;&lt;16] = 1</code>的时候还好好的吗？<br>大家都知道javascript的数组并不是真的数组，而只是一个特殊的以数组作为key的table而已，这点和lua是一样的。所以当我们在执行<code>a[2&lt;&lt;16] = 1</code>的时候，其实这生成的只不过是一个只有一个键值<em>2&lt;&lt;16</em>的表，空间只有1，这是没有任何问题的。</p>
<p>但当我们把一个数组作为arguments传递给一个函数时，情况就变了；同样，大家都知道arguments不是真的数组，它没有Array.push/pop等方法。但是我们可以把一个数组作为参数传递给apply方法，作为argumetns去调用一个函数。<br>实际的情况是，在这个时候你的数组虽然是一个table，但是在这个时候只能一个个的传递到栈上，没错,因为arguments是分配在Stack上的，而Array是分配在Heap上的。从某种意义上来数arguments才是真正的数组: 线性空间排序, 顺序访问。而Array更像上是Hash Table。接下来发生什么？javascript vm尝试去读取arguments中的参数，一个一个的把它放到调用栈上，传递给之后调用的函数,于是<code>for(var i = 0; i &lt; (2&lt;&lt;16); ++)...</code>，调用栈都被使用慢了！本来只占据Heap中一个位置，现在占据了整个栈的空间。而调用栈空间满了之后，会发生什么错误？就是我们开头看到的<em>RangeError: Maximum call stack size exceed.</em>， 而实际上叫做<em>Function arguments exceed the maximun limit.</em>更好些.</p>
]]></content>
    
    
      <category term="javascript, Array.push, push, Range Error" scheme="http://villadora.github.io/tags/javascript,%20Array.push,%20push,%20Range%20Error/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[interupt when hexo generating]]></title>
    <link href="http://villadora.github.io/2013/08/06/interupt-when-hexo-generating/"/>
    <id>http://villadora.github.io/2013/08/06/interupt-when-hexo-generating/</id>
    <published>2013-08-06T05:51:11.000Z</published>
    <updated>2013-08-06T06:02:52.000Z</updated>
    <content type="html"><![CDATA[<p>用<code>hexo generate</code>的时候有时强制中断了，下次再重新generate就会失败, 预计是<code>db.json</code>还没有完全生成完，而重新generate的时候会去尝试读<code>db.json</code>，这个时候就会报错，删除<code>db.json</code>就ok. 奇怪的是作者为什么在报错之后不直接重新生成<code>db.json</code>，毕竟这个文件只是用来做server的数据库，莫非还有别的用途?</p>
]]></content>
    
    
      <category term="hexo, interupt" scheme="http://villadora.github.io/tags/hexo,%20interupt/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SVG Spec]]></title>
    <link href="http://villadora.github.io/2013/08/06/svg-spec/"/>
    <id>http://villadora.github.io/2013/08/06/svg-spec/</id>
    <published>2013-08-06T03:34:06.000Z</published>
    <updated>2013-08-06T05:50:00.000Z</updated>
    <content type="html"><![CDATA[<h3 id="SVG的Painters_model">SVG的Painters model</h3>
<p>每个操作都会向输出设备修改某块区域的绘图，而不管之前在这块区域内的绘制是什么。这和很多的绘图或现实模型相似，接近底层容易实现。没有透明度的情况下，新的绘制会直接覆盖原来的区域，而有透明度的设置时，最终结果则按照Alpha Blending来计算。</p>
<h3 id="Rendering_Order">Rendering Order</h3>
<p>元素在svg内的排列顺序暗含了元素的绘制顺序，svg document fragment的第一个元素将会首先被绘制到输出设备上。</p>
<h3 id="groups">groups</h3>
<p>‘g’元素实际上是穿件了一个临时的独立的背景色为黑色但是背景透明的画布,’g’的子元素则在这块画布上进行绘制</p>
<h3 id="types_of_graphics_elements">types of graphics elements</h3>
<p>SVG支持三种基本的图形元素:</p>
<ul>
<li>Shapes: 用到最多的，主要由各种线和填充构成</li>
<li>Text: 字符的组合</li>
<li>Raster images: 类似于bitmap,是一组包含了颜色，透明度信息的数组</li>
</ul>
<h4 id="Shapes_and_Text">Shapes and Text</h4>
<p>字符实际上最终也是形状的一种，由<strong>stroke</strong>和<strong>fill</strong>构成, 对于有一些形状, 比如path, 可以定义一些<strong>marker symbol</strong>,主要用来绘制箭头等。<br>其中<strong>fill</strong>首先被绘制，然后是<strong>stroke</strong>, 最后是<strong>marker symbol</strong>, <strong>marker</strong>的绘制顺序是沿着形状的outline来进行，从形状的起始点开始到结束点。</p>
<p>Ref: <a href="http://www.w3.org/TR/SVG/render" target="_blank">http://www.w3.org/TR/SVG/render.html</a></p>
]]></content>
    
    
      <category term="svg, web, spec" scheme="http://villadora.github.io/tags/svg,%20web,%20spec/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hostname in mac]]></title>
    <link href="http://villadora.github.io/2013/07/08/hostname-in-mac/"/>
    <id>http://villadora.github.io/2013/07/08/hostname-in-mac/</id>
    <published>2013-07-08T01:30:00.000Z</published>
    <updated>2013-08-03T14:56:51.000Z</updated>
    <content type="html"><![CDATA[<p>在改写一个保存tmux状态的脚本(tmux-resurrect)的时候发现<code>hostname</code>这个命令拿到的是ip地址而不是我PROMPT里面的命令，这两个怎么会不一样呢？</p>
<p>在prompt里面的%m hostname通过以下途径获得：</p>
<ol>
<li>/etc/hostconfig: 在这个配置文件中配置</li>
<li>如果没找到就去/Library/Preferences/SystemConfiguration/preferences.plist中的’System&gt;System&gt;HostName’值</li>
<li>如果这个值为空，则通过逆向DNS查询找到ip地址</li>
<li>如果查询没找到才会用/Library/Preferences/SystemConfiguration/preferences.plist中的’System&gt;Network&gt;HostNames&gt;LocalHOstName’，这个也是用户在系统配置中的共享里配置的名字</li>
<li>最后如果这个也没查到，那就会返回localhost</li>
</ol>
<p>所以由于我hostconfig没配置，然后就找到preferences.plist中的HostName，也就是第二项。</p>
<p>而hostname命令就不一样了，好吧，这个过程是怎么样我也没找到，应该除了上述几个地方还有一些mac自己存放的配置文件，通过<code>scutil</code>来修改。只不过顺序和具体包含哪些不是很清楚。<br>只不过其中DNS查询在去找preferences.plist之前，所以我的<code>hostname</code>会返回ip地址</p>
<p>修改则可以通过</p>
<pre><code><span class="built_in">sudo</span> scutil --set HostName &lt;hostname&gt;
</code></pre><p>具体命令其他用法可以查看scutil(8) man page,可以看到 这个命令可以用来设置ComputerName LocalHostName和HostName。</p>
]]></content>
    
    
      <category term="mac, linux" scheme="http://villadora.github.io/tags/mac,%20linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTML5]]></title>
    <link href="http://villadora.github.io/2013/05/31/html5/"/>
    <id>http://villadora.github.io/2013/05/31/html5/</id>
    <published>2013-05-31T06:30:00.000Z</published>
    <updated>2014-05-01T12:15:07.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://dev.w3.org/html5/spec/Overview.html#introduction" target="_blank">http://dev.w3.org/html5/spec/Overview.html#introduction</a><br>HTML5 各方角力又开始了</p>
]]></content>
    
    
      <category term="html5" scheme="http://villadora.github.io/tags/html5/"/>
    
      <category term="web" scheme="http://villadora.github.io/tags/web/"/>
    
      <category term="Web" scheme="http://villadora.github.io/categories/Web/"/>
    
      <category term="HTML5" scheme="http://villadora.github.io/categories/Web/HTML5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA['$' in auto-mode-alist]]></title>
    <link href="http://villadora.github.io/2013/05/29/$-in-auto-mode-alist/"/>
    <id>http://villadora.github.io/2013/05/29/$-in-auto-mode-alist/</id>
    <published>2013-05-29T01:53:00.000Z</published>
    <updated>2013-08-03T14:56:51.000Z</updated>
    <content type="html"><![CDATA[<p>之前发现一个markdown文件载入之后一直要手动切换markdown-mode, 还要一遍遍的激活mode-hook上的flyspell-mode，实在很烦, 找了下原因，发现EmacsWiki:Auto-Mode-Alist上说:</p>
<p>“Note that \’ matches the end of a string, where as $ matches the empty string before a newline. Thus, $ may lead to unexpected behavior when dealing with filenames containing newlines. (Should be pretty rare… )”</p>
<p>也就是说”$”可能回匹配一个换行前的空字符，那个文件由于是从程序中生成的，所以名字中有了奇怪的字符，这样导致我之前写的”\.\(md\|markdown\)$”一直匹配不到,改成”\.\(md\|markdown\)\‘“就好了，好吧 这个正则够诡异的。</p>
]]></content>
    
    
      <category term="emacs, auto-mode" scheme="http://villadora.github.io/tags/emacs,%20auto-mode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Uglify-js Processing]]></title>
    <link href="http://villadora.github.io/2013/05/24/uglify-js-processing/"/>
    <id>http://villadora.github.io/2013/05/24/uglify-js-processing/</id>
    <published>2013-05-24T01:34:00.000Z</published>
    <updated>2013-08-03T14:56:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="UglifyJs_1">UglifyJs 1</h2>
<p>‘parse-js’:主要用来做词法和语法分析，把js文件转化成abstract syntax tree，方便后面的程序处理。相当于编译器中的front-end<br>‘process.js’:在ast的IR上做优化, 其中包括:</p>
<p>1.重新从ast生成javascript（真心觉得这个应该放到下一个stage，而不是整合在process.js中,这个已经是属于编译器生成目标码的阶段了， 然后发现在UglifyJs2中作者完全改变了这些设计），这个过程中就可以去掉不必要的空白字符等;<br>2.缩短变量名，猜想应该是用类似于寄存器分配的算法来分配变量名，中间会对一些global scope的变量做一些特殊处理，比如DOM暴露的接口啊,其他的库中export的变量啊之类;<br>3.其他的一些优化， 这些都是一些为了性能，和缩减字符做的一些小优化，并不会改动语义和影响到可读性。</p>
<pre><code><span class="bullet">* </span>[]取值变成.操作符  <span class="smartquote">```foo['</span>bar'] =&gt; foo.bar<span class="code">```</span>
<span class="bullet">* </span>去掉不必要的{}
<span class="bullet">* </span>..etc.
</code></pre><h2 id="UglifyJs_2">UglifyJs 2</h2>
<p>在生成ast之后，在topLevel scope上定义了figure_out_scope方法，提供了额外的关于变量定义等node的其他关联信息，这样在之后做mangle和其他优化的时候有了更多信息。之后的优化和更改都放在了一些transform和walker中。</p>
<p>只不过在设计的时候TreeWalker和ast定义在一起，不得不考虑ast结构来进行visit，而transform更是定义在walker之上，导致一个本来很简单的树遍历需要考虑很多复杂的情况，而且由于ast本身并没有父结点的ref，回溯的信息都放到了walker里面，而一些transform的操作在需要知道父结点相关信息的时候需要一个个的去定义不同node的情况。自己在deobfuscate中写了个travese.js，基本可以完成transform和walker的工作。还是觉得esprima这种纯json的ast比较简洁。</p>
]]></content>
    
    
      <category term="javascript, ast, parse, minification" scheme="http://villadora.github.io/tags/javascript,%20ast,%20parse,%20minification/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Description on Function/Object and other things in Javascript]]></title>
    <link href="http://villadora.github.io/2013/05/22/type-system-in-javascript/"/>
    <id>http://villadora.github.io/2013/05/22/type-system-in-javascript/</id>
    <published>2013-05-22T02:51:00.000Z</published>
    <updated>2013-08-06T03:54:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Pre-Knowledge">Pre-Knowledge</h2>
<p>Function is a Object, Object has a constructor and a property called ‘__proto__‘, and also you know what happens during the ‘=new=’ keyword (allocate memory; set __proto__ to <em>Function</em>.prototype; apply <em>Function</em> to new created object;)</p>
<h2 id="What’s_a_Function?">What’s a Function?</h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>    <span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> === <span class="literal">true</span> <span class="comment">// everything is a Object</span>
    <span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span> === <span class="literal">true</span> <span class="comment">// Function is a Function, interesting, right?</span>
    <span class="built_in">Function</span>.constructor === <span class="built_in">Function</span>  <span class="comment">// Function initialize by itself</span>
    <span class="built_in">Function</span>.prototype === <span class="built_in">Function</span>:Empty  <span class="comment">// Function has prototype because it's a Function </span>
    <span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>:Empty  <span class="comment">// Function has __proto__ because it's a Object</span>
</pre></td></tr></table></figure>

<p>From these above we can easily understand that Function is a Object (everything is Object), and also is a <em>Function</em>. as Object, its constructor is itself; and the prototype is the Empty Function(remember is not a</p>
<figure class="highlight function()"><figcaption><span>{}```); and as an instance of _Function_; it's '\_\_proto\_\_' property is set to Function.prototype, which is the Empty Function.</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>
Here is something interesting:

What is <span class="keyword">Function</span>:Empty? it's a empty <span class="keyword">function</span>? we can test it

``` javascript
    <span class="keyword">Function</span>.prototype instanceof Object === <span class="keyword">true</span> // <span class="keyword">Function</span>.prototype is a object, because everything is object
    <span class="keyword">Function</span>.prototype instanceof <span class="keyword">Function</span> === <span class="keyword">false</span> // <span class="keyword">Function</span>.prototype Empty <span class="keyword">Function</span> is not a <span class="keyword">Function</span>! it can be called mother of all the functions, the Force!!
    <span class="keyword">Function</span>.prototype.__proto__ === {].__proto__ === Object {} // the __proto__ of <span class="keyword">Function</span>:Empty is the same as a <span class="keyword">Function</span>
    <span class="keyword">Function</span>.prototype.prototype === undefined // Because it's not a <span class="keyword">Function</span>, so it don't have prototype
</pre></td></tr></table></figure>

<p>So the Function:Empty is an Object rather than a Function, but it’s the mother of all the functions; That is said that all the functions are clone from this one.</p>
<p>That’s make sense, right? Let’s go back to the prototype chain:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>     <span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Function</span> === <span class="literal">true</span>
</pre></td></tr></table></figure>


<p>Function is prototyped from Function, according to the object creating process: we allocate the memory first, then set ‘__proto__‘ to ‘Function.prototype’.. wait so ‘Function.prototype’ is also a Function, there is a cycling here, so we need something to break the cycle, that’s ‘Function.Empty’.</p>
<p>What about new functions like</p>
<figure class="highlight function"><figcaption><span>A() {}```? </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>
``` javascript
    A instanceof <span class="keyword">Function</span> === true // A <span class="keyword">is</span> a <span class="attribute">'Function</span>' Object
    A.__proto__ === <span class="keyword">Function</span>.prototype // A should has everything <span class="keyword">in</span> <span class="attribute">'Function</span>'
    A.constructor === <span class="keyword">Function</span> // A <span class="keyword">is</span> constructed by <span class="attribute">'Function</span>'
    A.prototype !== <span class="keyword">Function</span>.prototype // A.prototype <span class="keyword">is</span> a <span class="keyword">new</span> object, this <span class="keyword">is</span> belong <span class="keyword">to</span> A, <span class="keyword">and</span> should be initialized during <span class="keyword">Function</span>(). I believe that every <span class="keyword">new</span> <span class="keyword">function</span> has a <span class="keyword">new</span> object as its prototype, <span class="keyword">if</span> I<span class="attribute">'m</span> wrong correct me
</pre></td></tr></table></figure>

<h2 id="What’s_an_Object?">What’s an Object?</h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>    <span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> === <span class="literal">true</span> <span class="comment">//everything is object</span>
    <span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span> === <span class="literal">true</span> <span class="comment">// Object also is a Function</span>
    <span class="built_in">Object</span>.constructor === <span class="built_in">Function</span> [native code] <span class="comment">//Object is initialized by vm</span>
    <span class="built_in">Object</span>.prototype === <span class="built_in">Object</span> {} <span class="comment">// Object.prototype is the 'Object {}'</span>
    <span class="built_in">Object</span>.prototype === <span class="built_in">Function</span>.prototype.__proto__ === {}.__proto__ <span class="comment">// the 'Object {}' is unique</span>
    <span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span> <span class="comment">// 'Object {}' is not a Object in V8, it's a root object in native code</span>
</pre></td></tr></table></figure>

<p>Object is also an Object because ‘everything is an object’, and Object is also a Function; and just like cycling in ‘Function’, the Object also need a root, that is ‘Object {}’. </p>
<p>Actually, objects are not an instance of Object,  they are objects whose prototype is ‘Object{}’, which is Object.prototype, when we create objects with Object Function, the Object.prototype is set to obj.__proto__.</p>
<h2 id="New_is_a_mistake?">New is a mistake?</h2>
<p>As already said by many people, seen in Douglas’s book, ‘=new=’ keyword done things that can be done with <code>Object.create</code> and <code>Function.apply</code>, see <a href="http://stackoverflow.com/questions/3650892/what-does-the-new-keyword-do-under-the-hood" target="_blank">StackOverflow:what does ‘new’ word do under the hook</a>.</p>
<p>In class hierarchy, the Class and Instance are different things, but in prototype hierarchy, there is no class and instance things, there are only Objects. Just like rumor, the ‘new’ keyword added is because the Manager in Netscape ask them to make something looks like Java:-)</p>
<h2 id="Ref:">Ref:</h2>
<ol>
<li><a href="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Details_of_the_Object_Model" target="_blank">MDN Details of the Object Model</a></li>
</ol>
]]></content>
    
    
      <category term="javascript" scheme="http://villadora.github.io/tags/javascript/"/>
    
      <category term="type" scheme="http://villadora.github.io/tags/type/"/>
    
      <category term="prototype" scheme="http://villadora.github.io/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NodeJs中exec和spawn的差别]]></title>
    <link href="http://villadora.github.io/2013/05/07/differences-between-exec-and-spawn/"/>
    <id>http://villadora.github.io/2013/05/07/differences-between-exec-and-spawn/</id>
    <published>2013-05-07T05:41:00.000Z</published>
    <updated>2013-08-03T14:56:51.000Z</updated>
    <content type="html"><![CDATA[<p>在NodeJS中创建一个子进程有两种方式: <code>spawn</code>和<code>exec</code>；这两者都可以通过｀require(‘child_process’)`来引入。那么这两个有什么区别呢？我应该使用哪一个呢？</p>
<p>这两者的区别主要是在他们和父进程之间的IO处理上,<code>spawn</code>调用后返回的是一个流,可以对stdout上添加事件来响应流数据,如<code>stdout.on(&#39;data&#39;, function() {...})</code>；在这个过程中，子进程输出到stdout中的数据会调用callback，是处于一个流工作的模式下，有一点输出就处理。而<code>exec</code>则是将输出放到一个buffer里面，这个buffer的大小是可以通过maxBuffer这个option配置的，默认是200k.</p>
<p>比较有趣的是实际上<code>exec</code>调用的是<code>execFile</code>，然后在<code>execFile</code>里面最终调用的还是<code>spawn</code>(see <a href="https://github.com/joyent/node/blob/master/lib/child_process.js#L573" target="_blank">L573</a>, <a href="https://github.com/joyent/node/blob/master/lib/child_process.js#L602" target="_blank">L602</a>).只不过在调用时<code>on(&#39;data&#39;,function(chunk){...}</code>是像一个string buffer里卖弄写chuck罢了。</p>
<p>最后如果只是输出很小那么直接用<code>exec</code>就可以了，而如果子进程的输出很大，而分配一个那么大的buffer也不是很合时宜的时候，就是用<code>spawn</code>。</p>
]]></content>
    
    
      <category term="nodejs, chil_process, spawn, exec" scheme="http://villadora.github.io/tags/nodejs,%20chil_process,%20spawn,%20exec/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义git命令, like git-flow, git-extras]]></title>
    <link href="http://villadora.github.io/2013/05/06/custom-git-command/"/>
    <id>http://villadora.github.io/2013/05/06/custom-git-command/</id>
    <published>2013-05-06T03:56:00.000Z</published>
    <updated>2013-08-03T14:56:51.000Z</updated>
    <content type="html"><![CDATA[<p>git flow和git extras很强大，原先以为是用一些git alias定义git命令去调用shell脚本，之后看了代码才发现完全不是那么回事。</p>
<p>git的可扩展性非常强，去自定义一个git命令, 在unix环境下，你只需要在PATH中定义一个可执行的脚本，以”git=”开头，然后剩余的部分就是你的sub command的名字了。比如如果有一个”git-mark”的脚本，那么在执行git mark命令时，实际上git会去调用git-mark这个脚本。是不是很简单？</p>
<p>为了了解git对alias,builtin,custom command的执行顺序，弄了下脚本做测试。</p>
<ol>
<li>在有builtin的情况下，alias和custom command不起作用，就是说像log, status等这些命令是无法通过alias和custom command来覆盖的。</li>
<li>在没有builtin的情况下, custom command会先与alias之前，也就是说如果存在alias.try和git-try，那么在执行”git try”的时候始终会调用git-try而不是alias。</li>
</ol>
<p>这样顺序就是builtin &gt; custom command &gt; alias。</p>
]]></content>
    
    
      <category term="git, customize" scheme="http://villadora.github.io/tags/git,%20customize/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[同步调用在javascript中的应用]]></title>
    <link href="http://villadora.github.io/2013/04/26/usage-of-synchronize-tasks-in-javascript/"/>
    <id>http://villadora.github.io/2013/04/26/usage-of-synchronize-tasks-in-javascript/</id>
    <published>2013-04-26T02:54:00.000Z</published>
    <updated>2013-08-03T14:56:51.000Z</updated>
    <content type="html"><![CDATA[<p>在javascript中很多任务都是异步执行的，而在有些情况下，我们更希望利用同步的方式来组织：</p>
<ol>
<li>页面动画. 页面动画的执行现在即可以通过css也可以通过javascript来执行，理想的情况下自然是通过css来处理所有动画，但是在css并没有完全覆盖所有的动画并且设计总是在不断的涌现新的需求的情况下，很多时候我们的动画效果都是css和javascript混合执行的，而这个时候，我们希望在前一个css效果结束后才调用javascript之后的调用。或者两个javsacript的动画效果能够按照顺序执行。</li>
<li>page unload. 在执行page unload返回一些统计信息的时候，我们不希望函数被async的执行，否则在callback调用时页面已经被destory了，callback方法自然是没办法执行了。</li>
</ol>
]]></content>
    
    
      <category term="javascript" scheme="http://villadora.github.io/tags/javascript/"/>
    
      <category term="synchronize" scheme="http://villadora.github.io/tags/synchronize/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IE7的两个兼容性问题]]></title>
    <link href="http://villadora.github.io/2013/04/06/ie7de-liang-ge-jian-rong-xing-wen-ti/"/>
    <id>http://villadora.github.io/2013/04/06/ie7de-liang-ge-jian-rong-xing-wen-ti/</id>
    <published>2013-04-06T12:38:00.000Z</published>
    <updated>2013-08-03T14:56:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_获取href的属性_getAttribute(‘href’)">1. 获取href的属性 getAttribute(‘href’)</h2>
<p>在使用.getAttribute(‘href’)获取anchor上的’href’属性时，ie7的实现和其他的浏览器不一样：在ie里面会返回完整的url，而其他的浏览器则只会返回href的设置的值。而jQuery的attr是通过.getAttribute来拿属性的，也不可避免的存在了这个问题。stackoverflow上的建议是用.get(0).href。</p>
<p>ie7 has different implementation for .getAttribute(‘href’) with other browsers.</p>
<p>other browser will return the actual value in href attribute, but ie7 will return the full url of that link.</p>
<p>ref:<a href="http://stackoverflow.com/questions/1593174/wrong-extraction-of-attrhref-in-ie7-vs-all-other-browsers" target="_blank">http://stackoverflow.com/questions/1593174/wrong-extraction-of-attrhref-in-ie7-vs-all-other-browsers</a></p>
<h2 id="2-_‘mouseevent’穿透">2. ‘mouseevent’穿透</h2>
<p>在ie7中，使用绝对定位的元素如果’background-color’设为none或者transparent，那么鼠标事件则会完全忽略掉这个元素，而直接在藏在背后的元素上触发。</p>
<p>对于这类元素就只有设置他的background-color的值(不能为transparent)，而不能忽略。</p>
<p>For position:absolute element in IE7, if the background-color is none or transparent, the mouse events (like ‘click’, ‘mouseenter’,ect) will be triggered in the element that behind front one. Like a penetrability effect.</p>
<p>so make sure the absolute element and its children has a fixed background.</p>
]]></content>
    
    
      <category term="IE7, bugs" scheme="http://villadora.github.io/tags/IE7,%20bugs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Orion: Next Eclipse?]]></title>
    <link href="http://villadora.github.io/2013/04/03/orion-next-eclipse/"/>
    <id>http://villadora.github.io/2013/04/03/orion-next-eclipse/</id>
    <published>2013-04-03T02:28:00.000Z</published>
    <updated>2013-08-03T14:56:51.000Z</updated>
    <content type="html"><![CDATA[<p>Orion是一个开源的online IDE，javascript的client和java的server,也是属于Eclipse Project下面的一个重要项目；希望打造一个online版的eclipse。</p>
<p>比较好奇的是居然没有做成比较流行的SPA(Single Page Application)的形式，而是可以打开多个tab，并且允许你通过link共享，这是好处吧，不好的是这样每次做新的操作都要切换tab并且等待刷新，用户体验不是很好。就不能两者都结合起来么？</p>
<p>Link: <a href="https://orionhub.org" target="_blank">https://orionhub.org</a></p>
]]></content>
    
    
      <category term="IDE, Eclipse, Orion, Web" scheme="http://villadora.github.io/tags/IDE,%20Eclipse,%20Orion,%20Web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Array slice in Ruby]]></title>
    <link href="http://villadora.github.io/2013/03/26/array-slice-in-ruby/"/>
    <id>http://villadora.github.io/2013/03/26/array-slice-in-ruby/</id>
    <published>2013-03-26T09:22:00.000Z</published>
    <updated>2013-08-03T14:56:51.000Z</updated>
    <content type="html"><![CDATA[<p>Ruby的文档实在太省略了,之前用slice不是很理解结果，在stackoverflow上面发现一个非常不错的<a href="http://stackoverflow.com/questions/3568222/array-slicing-in-ruby-looking-for-explanation-for-illogical-behaviour-taken-fr" target="_blank">解释</a>，也得到了confirm. </p>
<p>可以看到ruby的array.slice的处理是用元素之间的space来标记index的。</p>
]]></content>
    
    
      <category term="编程, Ruby, slice, stackoverflow" scheme="http://villadora.github.io/tags/%E7%BC%96%E7%A8%8B,%20Ruby,%20slice,%20stackoverflow/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Boot Configuration Data]]></title>
    <link href="http://villadora.github.io/2013/03/01/boot-configuration-data/"/>
    <id>http://villadora.github.io/2013/03/01/boot-configuration-data/</id>
    <published>2013-03-01T05:18:00.000Z</published>
    <updated>2013-08-03T14:56:51.000Z</updated>
    <content type="html"><![CDATA[<p>Boot Configuration Data</p>
<p>Boot Configuration Data (BCD) is a firmware-independent database for boot-time configuration data. It replaces the boot.ini that was used by NTLDR, and is used by Microsoft’s new Windows Boot Manager.</p>
<p>Boot Configuration Data are stored in a data file that has the same format as the Windows Registry.[1] The file is located either on the EFI System Partition (on machines that use Extensible Firmware Interface firmware) or in \Boot\Bcd on the system volume (on machines that use IBM PC compatible firmware).</p>
<p>Boot Configuration Data may be altered using a command-line tool (bcdedit.exe), using Registry Editor (regedit.exe), using Windows Management Instrumentation, or with third party tools like EasyBCD.</p>
<p>Boot Configuration Data contain the menu entries that are presented by the Windows Boot Manager, just as boot.ini contained the menu entries that were presented by NTLDR. These menu entries can include:</p>
<ol>
<li>Options to boot Windows Vista by invoking winload.exe.</li>
<li>Options to resume Windows Vista from hibernation by invoking winresume.exe.</li>
<li>Options to boot a prior version of the Windows NT family by invoking its NTLDR.</li>
<li>Options to load and to execute a volume boot record.</li>
</ol>
<p>Boot Configuration Data allows for third party integration so anyone can implement tools like diagnostics or recovery options.</p>
]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[原尚书记对发行审核制度改革的评价]]></title>
    <link href="http://villadora.github.io/2012/07/14/comments-on-ipo-system-in-china/"/>
    <id>http://villadora.github.io/2012/07/14/comments-on-ipo-system-in-china/</id>
    <published>2012-07-14T05:03:00.000Z</published>
    <updated>2013-08-06T03:35:55.000Z</updated>
    <content type="html"><![CDATA[<p>在位的可以说不能做，大家都看得到问题所在，但是谁会去动这一下呢?</p>
<p>“发行审核制度改革最先推的是保荐人制度，就是整体上讲，要让发行制度更加市场化。市场化的核心是让市场的主体发挥作用，让他们归位尽责。如果市场主体该做的事情不去做，市场化就是缘木求鱼，方向就不对。因此，最早推的是保荐人制度。保荐人制度推出，就是让保荐人在公司上市过程中承担更大责任。这样，保荐人帮助公司做好做细上市前的工作，促使它在上市前就完成改制，按照股份制公司、公众公司的标准去改造；而不是对它进行包装，包装之后让它来过关。我曾经把这个变化比喻为：过去是过一个关，现在把它变成了一个管子；公司要想过这个关，就必须按照公众公司的标准去改造，才能过这个关，前期工作应该做得更好些。所以保荐制度是最先改革的，然后才是发审委的改革。</p>
<p>　　发审委的改革，就是让它更加阳光化，更加专业化。过去有一个发审委的名单，据说有80多个人。那个时候名单是保密的，听说市场还有卖这个名单的。关键问题是这个名单本身就不透明，缺乏社会约束。</p>
<p>　　第一，阳光是最好的消毒剂。于是，证监会就聘请专业的人来参加，提高审核的专业水平。第二，这些人员大部分是会计师、律师。他们的职业生涯是和社会的认可度联系在一起的，是受社会监督的。第三，在发审制度上保证能够集体决策，而不是哪一个人说了就能过关。这样就推出了发审委制度改革，发审委名单比过去缩小了，但是变成了专职的。主要是从会计师事务所和律师事务所引进专业队伍。发审委的改革，从目前看是成功的，他们确实能够恪尽职守，客观地发表意见。从工作程序上，我们也做了一些安排，比如发审委所有工作都要有工作底稿，以后可能还要追责，有非常严格的要求，保证能够最大限度正常地发挥它应该发挥的职能，保护投资者的合法权益。</p>
<p>　　上市公司通过发审委审核以后，到市场上开始定价。我们希望定价机制更加市场化。这个市场化过程当中也有一个归位尽责的问题。上市公司总是希望自己的股票卖得贵一点。但是在成熟市场上，发行人看重的并不是能融多少资，而是确定一个合理的价格，让这个价格保持合理的逐步增长的空间。这样下来，投资者对上市公司的认可度会提高，使得上市公司未来有更好的发展机会的时候还可以再顺利融资。我们的企业在这方面还有差距，总是觉得有这么一次机会，赶快融资，融得越多越好。企业有抬价的动机。另一方面，我们的买方应该使劲压价，但是靠谁去压价，怎么样形成价格的博弈，这当中，保荐人、承销商就起了比较重要的作用。比较成熟的市场上，承销商的作用是，一手托买家，一边把公司股票卖出去，卖给熟悉的投资者，这样达到利益的均衡：卖方觉得卖的价格合适，买方觉得买的股票有上涨空间。我们现在没有让承销商搞配售制度，就是怕配售的时候又有些权力寻租。我们的目标是在市场化过程中，让市场主体归位尽责，逐步培育这样的机制。就是上市公司在发行股票的时候要考虑得更长远一些，能够保证公司逐步成长；承销商要逐步变成一手托两家，均衡双方的利益。</p>
<p>　　现在离这个目标还有差距，今后在改革过程中要朝着这个方向努力，一方面是更加市场化，另一方面是逐步建立起市场各方都能归位尽责，形成一种机制。这种机制建立起来之后，把现在的核准制逐步改为注册制才有条件。如果说机制没有建立起来，我们的审批条件先放松，恐怕对投资者权益不是保护。市场上有人说，如果不改变这种行政审批，市场供求是不平衡的，发行价格总是维持在较高水平。这其实是技术层面的问题，发得快一点也是一样的，也解决了市场供求问题。但是，现在我们缺的是这种制衡机制。这种机制没建立起来，就把制度改了，可能未必是好事。</p>
<p>　　记者：按照您的规划，注册制还有多长时间才能实现？</p>
<p>　　尚福林：市场发展当中，有些是不大好规划的，比如做一些制度上的改变，设置多层次市场，现在我们可以做一些规划。有些事情的改变是要靠市场机制的培育，看它的成熟程度，这是需要时间的，需要根据市场参与各方的成熟程度来决定什么时候推出。市场化恰恰就是有些地方是规划不到的。有的时候大家经常问我，你这件事情有没有时间表？什么时间推出？我经常讲，没有时间表。不是说我有时间表不说，我确实是没有时间表。而且我在证监会工作安排上，总是要求做到水到渠成，这样才能使改革顺利推出。这是更市场化的做法，是更适应市场需要的一种工作方法。这种工作方法不是说工作可以拖沓，而是要积极地创造条件，培育条件，在条件成熟的时候再推出。条件不成熟，设立个“到哪天必须推出”的时间表，如果到时条件不成熟硬推出去，对市场是一种伤害。我总是说，要符合市场发展规律，要符合中国市场发展规律，我们在具体工作中也要体现出这种要求。这种方法是符合科学发展观的。</p>
<p>　　规范的目的是什么？是促进市场能够健康发展，而不是把市场规范得失去活力，或是市场效率极大降低，这也不是我们监管的目标。我们的监管目标是维护市场三公原则，提高市场效率。方法上就是要规范发展，规范和发展相辅相成，有了规范才能更好地发展。”</p>
<p>　　　　　　　　　　　　　　　　　　　　　－－－　尚福林</p>
]]></content>
    
    
      <category term="经济,股市,发行审核制度" scheme="http://villadora.github.io/tags/%E7%BB%8F%E6%B5%8E,%E8%82%A1%E5%B8%82,%E5%8F%91%E8%A1%8C%E5%AE%A1%E6%A0%B8%E5%88%B6%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Graphviz 几种layout的mode]]></title>
    <link href="http://villadora.github.io/2012/07/14/graphviz-ji-chong-layoutde-mode/"/>
    <id>http://villadora.github.io/2012/07/14/graphviz-ji-chong-layoutde-mode/</id>
    <published>2012-07-14T04:30:00.000Z</published>
    <updated>2013-08-03T14:56:51.000Z</updated>
    <content type="html"><![CDATA[<p>graphviz的工具dot主要有6种filter：<br>dot<br>neato<br>twopi<br>circo<br>fdp<br>sfdp<br>其中dot可以用来绘制有向图，但是似乎是要在原始graph里面有layout信息<br>neato用来绘制无向图，layout的结果是根据force-directed algorithms也就是spring algorithms算出来的。spring layout是一个对现实进行模拟的很好例子，它利用胡克定律和库伦定律，node之间的作用力由node本身相互之间的吸引力和斥力以及edge上的弹力所决定。经过多次迭代，最终会达到一个力平衡的状态。之前在做training project时还写了一个javascript版的spring layout.<br>而nodes之间的力有库伦定律得出，edges上的力则有胡克定律得出。在这样一个算法中，各个参数和迭代次数的选择对于layout的结果是非常重要的。</p>
<p> twopi是一个绘制radial layout  (see G. Wills, Symposium on Graph Drawing GD’97, September, 1997)的filter，首先它会选择一个root node，然后根据其他nodes到root的步长来决定它们分布在那个环上，比如步长为1的就分布在离圆心最近的一个环上，步长为2就分布在离圆心第二远的环上，依次类推。</p>
<p>  circo则是根据circular layout (see Six and Tollis, GD ’99 and ALENEX ’99, and Kaufmann and Wiese, GD ’02.)来绘制layout. 该算法和上面的radial layout类似，不同的是会尽量将有biconncted的node group放在一个环上，这样可以尽可能的减少环与环之间的edges. 当graph是一个outerplanar的时候，这个算法绘制出来的是一个plannar layout.<br>  plannar就是平面图，也就是说存在一种绘制方法将graph画在一个平面上而没有边交叉。而outerplannar则是在绘制成为plannar之后，所有的node都处在graph的boundary上，即没有一个node被围在中心。</p>
<p>   fdp和sfdp两个filter都是利用了一种spring layout来绘制无向图，这种spring layout manual上说是 “a force-directed approach in the spirit of Fruchterman and Reingold (cf. Software-Practice &amp; Experience 21(11), 1991, pp. 1129-1164)”; 也没有看， 不知道和一般的spring layout有什么区别。后面sfdp实际上是scale-fdp，算法应该是可以多路同时计算的，因此更快，适合于large graphs.</p>
]]></content>
    
    
      <category term="graphviz" scheme="http://villadora.github.io/tags/graphviz/"/>
    
      <category term="图形学" scheme="http://villadora.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="layout" scheme="http://villadora.github.io/tags/layout/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shanghai Barcamp]]></title>
    <link href="http://villadora.github.io/2012/05/14/shanghai-barcamp/"/>
    <id>http://villadora.github.io/2012/05/14/shanghai-barcamp/</id>
    <published>2012-05-14T04:53:00.000Z</published>
    <updated>2013-08-03T14:56:51.000Z</updated>
    <content type="html"><![CDATA[<p>早上起来晚了，晚睡晚起的习惯很不好！总是有段时间会养成这样的不好习惯，过一段时间又会早睡早起。总结的说，去了还是有不少收获的，而且刚好就在前一段时间看了不少关于vc和初期投资培养方面的知识，结果这次居然就用到了，不然有几个就不知道在讲什么。</p>
<p>早上一眼睁开就发现已经九点半了，然后打开电脑弄了半天才搞懂创智天地在那，知道了原来可以坐公交过去的。真正等到一身轻出门的时候已经是10：00了，可是去了才知道，时间刚刚好～ 哈哈 到的时候是10：40，还没有一个speech开始！大家都是很不守时，后来觉得忘带了笔记本（不是电脑！）和相机，只好依靠大脑记点东西，靠着不靠谱的手机拍个不清晰的照片。</p>
<p>下面是今天听过的几个:</p>
<hr>
<p>1) SVB Financial Group —— How to make a technique company in China? SVB以前没听过，后来知道是硅谷银行，做的讲座其实也有宣传的部分，大概内容包括：</p>
<p>首先要考虑的问题：企业接受怎样的货币投资，是RMB还是USD，如果是USD是选择怎样的结构，Offshore还是VIE等；这个主要影响到税收和资本流动性。之后考虑最终的退出机制是什么，这些基本上是他们做投资和牵头投资时所考虑的问题；接下来就是根据business model, team来分析是否值得投。但从描述来看，SVB在其中也是充当一个桥梁的作用，毕竟性质还是BANK，美国的regulation方面也不会允许性质为BANK的Entity去做创业阶段的风险投资。不过有一个比较有创新的finance product是 venture term debt，SVB说是这种debt他们会严格审查，确认了盈利模式和发展之后才发放的，但是他们是不会要求换取equity的，回报率一般在15%-20%。回来后在网上看了下，这种debt在美国很多还是要求换取的是可转债或者和一些warrent组合一起来提供保险。</p>
<p>结束后和这次过来的两个SVB的员工聊天，发现其中一个是05SS的，这个世界真小。了解到我漏看了后面的Financial Group，SVB下面不止有银行，我甚至怀疑他们的银行更多的是做private bank，用来为其他的entity如Fund，Capital Investor等提供资金。它这样将实际投资的Entity分开，用来剥离风险。</p>
<p>2) App Evolution —— by david kennan David同学还是很有想法的，不过对于其前景不是很看好；趋势是对了；技术也有些眉头，但还是不是现成的；市场在现来看却不大，而培养市场这个步骤却是自己也是任何企业无法短时间内做到的，也许google和apple这种巨头利用其在技术圈内的粉丝群能够在短期内推广，但是利益分割模式（也就是david的商业模式）在细节上还有很多问题，需要实践中来检验了。</p>
<p>phase 1在技术上几乎不可行，太难了；而他所追求的编程行业内的微经济（mini economy）能够在初期培养多大的市场很大程度上决定了这个项目的成功与否。可行的phase 2更想是想创建一个standard，但在技术领域就如同现实中一样，这些都需要authority来帮忙推广，所以最终与大公司合作甚至出路就是被收购都是无法避免的。 后来和david聊了下，互相留了email，倒是对他这个项目技术方面的实现有点想法。</p>
<p>下午不知道是有点困了还是怎么了，听的打不起精神来</p>
<p>3）openstack 知道大家都在倒腾cloud operation system，也听过openstack，但是对这方面真不是很了解，只知道hapdop和map reduce。 属于技术简介，演讲者还是debian的狂热爱好者，也是debian社区的成员。反正听的不是很多，回头去看openstack的文档。</p>
<p>4）机器人自动检测 听完了上一场，上一个听完后换了个场，不过这个已经到了快结束了；大致内容是机器人手臂+激光扫描+3D建模；觉得如果能够和生产线结合起来做自动化质量控制还是很有前途的，如果硬要专到困难，市场需求下而且作用不到的自动维修上，那么就没啥前途了；产品失败的可能性多种多样，特别是内部性损坏，按照他的展示根本就不可能自动修复，而如果是外部性损坏，他也只能修复整体化的模块：比如一整块钢，塑料等，如果是一个已经组装好了的收音机呢？而这种整块的产品一般处理方法就是回炉重新做就是了，损失不大（如果差错率高，那买下那条生产线的好去死了），何必要买一个100w的设备去修理可能出现的0.1%的质量修复呢；不过在高精度市场还是有前途的，比如军工航天产业，一点点误差都是要人命的，而在这样的行业中不少精密仪器的组成部件都很复杂，重新制作需要很多到供需；但是这样对于修复机器人要求非常高，如果修复出现的问题的话，那就可以制作一个制造这种高精度复杂组件的机器人了不是？所以可行的方案还是用来检测误差，同时由于有模型比对，所以这个设备可以将结果传递给生产线去自我调整。</p>
<p>5) Forge+Entrepreneur = Make something cool 一个美籍上海宁小孩讲的，约莫这22岁左右，美国文化熏陶果然是比较容易创新和开放，很有passion，孩子家境也不错；当讲的东西有感觉是受到了这部电影的启发：make something cool。不过现实却不是这样，他创新是为了寻找cool的东西并且也期待这在其中找到商机，而在国内，很多人是因为不满足与现状，期待这一夜成名，怀着改变生活的梦想才创业的，一开始就是迫于“成就一番事业”的压力，这压力是自己给的，不可能只是为了一个毫无意义的cool来进行创业；一个人若是投入了全部的家当去创办一个企业，能指望只是做一个cool的东西玩吗？而这位小孩子自然是没有这种压力的，不过他有个理解我却很赞同，创业的成功不是说你努力计算就能够实现的，有时候精心的准备business plan，去找投资去谋求盈利，甚至夸大自己的事业（看到cctv2里面那些在台上拉投资的人就像笑，感觉中国一年内就要冒出100个facebook的样子）；这些都不如追求简单，把一个简单的事做到极致来的更快更便捷。因为所有的成功都是要看机遇的，时代的机遇和社会的机遇不是能以人的意志为转移的。</p>
<p>6) Love Hotel 这个是讲字符编码的，后面进去的时候只听到了关于unicode的部分，才知道现在的unicode如此的千奇百怪，连国旗，表情都成为了unicode的一部分，因为有了男女的图标，由于不得歧视同性恋，所以unicode还加入了男男和女女的图标… 比较寒。 内容非常有意思，简直就是一部曲折离奇的搞怪史。后面还展示了一个图标是LoveHotel，好吧，这也能被加入unicode， 哈哈</p>
<p>7) co-working - people squared 公司的图标很有意思，也是本次活动的赞助方之一。不知道co-working的上网搜一下就知道，这个还是很有前途的，不过需要环境不是，如果市场需求不够，那么就赢利不起来。好比大家都在创业，如同在加州淘金的人群的时候，有人发现卖水淘金的工具比淘金更容易发财。唯一的问题在于外部是否提供了一个创业的环境，使得能够在co-working workshop中的企业能够发展起来。上海能够提供这样的环境么？</p>
<p>8) urban farming 绿色城市，无土培育，利用建筑物本身来培养城市所需的农作物，很不错也很有意思，不过对于人口密度如此之大的中国，不符合国情。</p>
<p>9)AngelVest 基本就是介绍自己公司，由于之前对于Angel Investor和VC都有所了解了，所以也就觉得没啥意思了。这个AAMA的中国分支还算有点名气吧。不多说了，觉得比Innovation Work看起来顺眼，IW可能对于那些有项目的人和投资方来说很不错，但是四处招摇撞骗把刚毕业的大学生骗进去做苦力就不对了，过于急功近利，即使成功，在那样的地方，开复同学还负责苦工之后的企业家管理技能培训不？如果不，那些付出汗水和艰辛的人最后能够胜任自己创造起来的企业中的管理职位吗？</p>
<p>好了 就这么多了，累了不写了，可能还有一些漏掉了。这次活动组织起来还是很不错的，这次通知知道的晚没准备，下次有机会到是有好几个topic想讲一讲的。</p>
]]></content>
    
    
  </entry>
  
</feed>
